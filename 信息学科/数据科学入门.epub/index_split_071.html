<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos333025" class="calibre_"><span class="calibre6"><span class="bold"> 10.1　探索你的数据 </span></span></p><p class="calibre_">当确定了需要研究的问题，并已获取了一些数据时，你摩拳擦掌地恨不得马上建模求解。但是，你需要克制一下。首先，你应该<span class="bold">探索</span> 数据。</p><p id="filepos333336" class="calibre_"><span class="calibre6"><span class="bold"> 10.1.1　探索一维数据 </span></span></p><p class="calibre_">最简单的情形是，你得到的一个数据集合仅仅是一维数据集。比如，它们可以是每个用户在你的网站上平均每天花费的时间，每个数据科学教程视频的观看次数，或者是你的数据科学图书馆中每本数据科学书的页数。</p><p class="calibre_">第一步显然是计算一些总结性统计数据。比如你可能想知道你的数据集中有多少个数据点，最小值是多少，最大值是多少，平均值是多少，或者标准差是多少。</p><p class="calibre_">如果你仍不能很好地理解以上步骤，那么下一步最好是绘出直方图，即将你的数据分组成离散的<span class="bold">区间</span> （bucket），并对落入每个区间的数据点进行计数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def bucketize(point, bucket_size):<br class="calibre12"/>    """floor the point to the next lower multiple of bucket_size"""<br class="calibre12"/>    return bucket_size * math.floor(point / bucket_size)<br class="calibre12"/><br class="calibre12"/>def make_histogram(points, bucket_size):<br class="calibre12"/>    """buckets the points and counts how many in each bucket"""<br class="calibre12"/>    return Counter(bucketize(point, bucket_size) for point in points)<br class="calibre12"/><br class="calibre12"/>def plot_histogram(points, bucket_size, title=""):<br class="calibre12"/>    histogram = make_histogram(points, bucket_size)<br class="calibre12"/>    plt.bar(histogram.keys(), histogram.values(), width=bucket_size)<br class="calibre12"/>    plt.title(title)<br class="calibre12"/>    plt.show()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">比如，考虑以下两个数据集：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>random.seed(0)<br class="calibre12"/><br class="calibre12"/># -100到100之间均匀抽取<br class="calibre12"/>uniform = [200 * random.random() - 100 for _ in range(10000)]<br class="calibre12"/><br class="calibre12"/># 均值为0标准差为57的正态分布<br class="calibre12"/>normal = [57 * inverse_normal_cdf(random.random())<br class="calibre12"/>          for _ in range(10000)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这两个数据集的均值都接近 0，标准差都接近 58 ，但它们的分布非常不同。图 10-1 展示了均匀分布。</p><p class="calibre_12"><img src="images/00084.jpg" class="calibre_76"/>
</p><p class="calibre_">
<span class="bold">图 10-1：均匀分布的直方图</span>
</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>plot_histogram(uniform, 10, "均匀分布的直方图")<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">而图 10-2 展示了正态分布：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>plot_histogram(normal, 10, "正态分布的直方图")<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这两种分布有非常不同的最大值和最小值。但是，仅仅知道这一点并不足以理解它们有何差异。</p><p class="calibre_12"><img src="images/00129.jpg" class="calibre_77"/>
</p><p class="calibre_">
<span class="bold">图 10-2：正态分布的直方图</span>
</p><p id="filepos336722" class="calibre_"><span class="calibre6"><span class="bold"> 10.1.2　二维数据 </span></span></p><p class="calibre_">现在假设你的数据集是二维的。也许在每天上网时间之外还增加了数据科学工作年限。你当然会希望能从每个维度上单独理解数据，但也许你更希望综合两个维度来考察数据。</p><p class="calibre_">比如，考察下面一个伪数据集：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def random_normal():<br class="calibre12"/>    """returns a random draw from a standard normal distribution"""<br class="calibre12"/>    return inverse_normal_cdf(random.random())<br class="calibre12"/><br class="calibre12"/>xs = [random_normal() for _ in range(1000)]<br class="calibre12"/>ys1 = [ x + random_normal() / 2 for x in xs]<br class="calibre12"/>ys2 = [-x + random_normal() / 2 for x in xs]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你对 <tt class="calibre7">ys1</tt> 和 <tt class="calibre7">ys2</tt> 运行 <tt class="calibre7">plot_histogram</tt> 程序，会得到很相似的直方图（事实上，两个正态分布的均值和标准差都相同）。</p><p class="calibre_">但是在联合分布上，每个都与 <tt class="calibre7">xs</tt> 有很大差别，如图 10-3 所示：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>plt.scatter(xs, ys1, marker='.', color='black', label='ys1')<br class="calibre12"/>plt.scatter(xs, ys2, marker='.', color='gray', label='ys2')<br class="calibre12"/>plt.xlabel('xs')<br class="calibre12"/>plt.ylabel('ys')<br class="calibre12"/>plt.legend(loc=9)<br class="calibre12"/>plt.title("差别很大的联合分布")<br class="calibre12"/>plt.show()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_19"><img src="images/00036.jpg" class="calibre_78"/>
</p><p class="calibre_">
<span class="bold">图 10-3：两个不同的 </span><tt class="calibre7"><span class="bold">ys</span></tt><span class="bold"> 的散点图</span>
</p><p class="calibre_">如果你考察相关性，差异会非常明显：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>print correlation(xs, ys1)    # 0.9<br class="calibre12"/>print correlation(xs, ys2)    # -0.9<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos338902" class="calibre_15"><span class="calibre6"><span class="bold"> 10.1.3　多维数据 </span></span></p><p class="calibre_">对于多维数据，你可能想了解各个维度之间是如何相关的。一个简单的方法是考察相关矩阵（correlation matrix），矩阵中第 <span class="italic">i</span> 行第 <span class="italic">j</span> 列的元素表示第 <span class="italic">i</span> 维与第 <span class="italic">j</span> 维数据的相关性：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def correlation_matrix(data):<br class="calibre12"/>    """returns the num_columns x num_columns matrix whose (i, j)th entry<br class="calibre12"/>    is the correlation between columns i and j of data"""<br class="calibre12"/><br class="calibre12"/>    _, num_columns = shape(data)<br class="calibre12"/><br class="calibre12"/>   def matrix_entry(i, j):<br class="calibre12"/>       return correlation(get_column(data, i), get_column(data, j))<br class="calibre12"/><br class="calibre12"/>   return make_matrix(num_columns, num_columns, matrix_entry)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">一个更为直观的方法（如果维度不太多）是做<span class="bold">散点图矩阵</span> （图 10-4），以展示配对散点图。通过命令 <tt class="calibre7">plt.subplots()</tt> 可以生成子图。我们给出了行数和列数，它返回一个 <tt class="calibre7">figure</tt> 对象（我们不会用到它）和一个 <tt class="calibre7">axes</tt> 对象的二维数组（每个都会绘出）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import matplotlib.pyplot as plt<br class="calibre12"/><br class="calibre12"/>_, num_columns = shape(data)<br class="calibre12"/>fig, ax = plt.subplots(num_columns, num_columns)<br class="calibre12"/><br class="calibre12"/>for i in range(num_columns):<br class="calibre12"/>    for j in range(num_columns):<br class="calibre12"/><br class="calibre12"/>        # x轴上column_j对y轴上column_i的散点<br class="calibre12"/>        if i != j: ax[i][j].scatter(get_column(data, j), get_column(data, i))<br class="calibre12"/><br class="calibre12"/>        # 只有当 i == j时显示序列名<br class="calibre12"/>        else: ax[i][j].annotate("series " + str(i), (0.5, 0.5),<br class="calibre12"/>                                xycoords='axes fraction',<br class="calibre12"/>                                ha="center", va="center")<br class="calibre12"/><br class="calibre12"/>        # 除了图的左侧和下方之外，隐藏图的标记<br class="calibre12"/>        if i &lt; num_columns - 1: ax[i][j].xaxis.set_visible(False)<br class="calibre12"/>        if j &gt; 0: ax[i][j].yaxis.set_visible(False)<br class="calibre12"/><br class="calibre12"/># 修复右下方和左上方的图标记<br class="calibre12"/># 因为它们只有文本，是错误的<br class="calibre12"/>ax[-1][-1].set_xlim(ax[0][-1].get_xlim())<br class="calibre12"/>ax[0][0].set_ylim(ax[0][1].get_ylim())<br class="calibre12"/><br class="calibre12"/>plt.show()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_19"><img src="images/00020.jpg" class="calibre_79"/>
</p><p class="calibre_">
<span class="bold">图 10-4：散点图矩阵</span>
</p><p class="calibre_">通过这些散点图你会看出，序列 1 与序列 0 的负相关程度很高，序列 2 和序列 1 的正相关程度很高，序列 3 的值仅有 0 和 6，并且 0 对应序列 2 中较小的值，6 对应较大的值。</p><p class="calibre_">这是一种能让你查看变量之间大概的相关度的快捷方法（除非你为了查看更加具体的效果而花费数小时调整 <tt class="calibre7">matplotlib</tt> ，这样就不快捷了）。</p><div class="mbp_pagebreak" id="calibre_pb_71"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
