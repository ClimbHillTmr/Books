<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos583740" class="calibre_"><span class="calibre6"><span class="bold"> 19.6　自下而上的分层聚类 </span></span></p><p class="calibre_">另一种聚类方法是采用自下而上的方式“培养”聚类，为此，我们可以借助下列方式：</p><p class="calibre_">1. 利用每个输入构成一个聚类，当然每个聚类只包含一个元素；</p><p class="calibre_">2. 只要还剩余多个聚类，就找出最接近的两个，并将它们合二为一。</p><p class="calibre_">最后，我们将得到一个包含所有输入的巨大的聚类。如果我们将合并顺序记录下来，就可以通过拆分的方法来重建任意数量的聚类。举例来说，如果我们想得到 3 个聚类，那么只要撤销最后两次合并就可以了。</p><p class="calibre_">我们将使用一种非常简单的方法来表示聚类。首先，我们的数值将进入<span class="bold">叶</span> （leaf）聚类中，这时我们将其表示为一元组：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>leaf1 = ([10, 20],)   # 要创建一元组，需要在末尾加一个逗号<br class="calibre12"/>leaf2 = ([30, -15],)  # 否则Python会把括号当成单纯的括号<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们通过<span class="bold">合并</span> 上面的聚类来培育新的聚类，并将其记为二元组（合并次序，子聚类）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>merged = (1, [leaf1, leaf2])<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们稍后会介绍合并次序，但现在不妨先来创建一些辅助函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def is_leaf(cluster):<br class="calibre12"/>    """a cluster is a leaf if it has length 1"""<br class="calibre12"/>    return len(cluster) == 1<br class="calibre12"/><br class="calibre12"/>def get_children(cluster):<br class="calibre12"/>    """returns the two children of this cluster if it's a merged cluster;<br class="calibre12"/>    raises an exception if this is a leaf cluster"""<br class="calibre12"/>    if is_leaf(cluster):<br class="calibre12"/>        raise TypeError("a leaf cluster has no children")<br class="calibre12"/>    else:<br class="calibre12"/>        return cluster[1]<br class="calibre12"/><br class="calibre12"/>def get_values(cluster):<br class="calibre12"/>    """returns the value in this cluster (if it's a leaf cluster)<br class="calibre12"/>    or all the values in the leaf clusters below it (if it's not)"""<br class="calibre12"/>    if is_leaf(cluster):<br class="calibre12"/>        return cluster      # 已经是一个包含值的一元组<br class="calibre12"/>    else:<br class="calibre12"/>        return [value<br class="calibre12"/>                for child in get_children(cluster)<br class="calibre12"/>                for value in get_values(child)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">为了合并相距最近的聚类，我们需要明确聚类之间的距离的概念。为此，我们将使用两个聚类的元素之间的<span class="bold">最小</span> 距离，据此将两个挨得最近的聚类合并（但有时会产生巨大的链式聚类，但是聚类之间却挨得不是很紧）。如果想得到紧凑的球状聚类，可使用<span class="bold">最大</span> 距离，而不是最小距离，因为使用最大距离合并聚类时，它会尽力将两者塞进一个最小的球中。实际上，这两种距离都很常用，就像<span class="bold">平均</span> 距离也很常用一样：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def cluster_distance(cluster1, cluster2, distance_agg=min):<br class="calibre12"/>    """compute all the pairwise distances between cluster1 and cluster2<br class="calibre12"/>    and apply _distance_agg_ to the resulting list"""<br class="calibre12"/>    return distance_agg([distance(input1, input2)<br class="calibre12"/>                         for input1 in get_values(cluster1)<br class="calibre12"/>                         for input2 in get_values(cluster2)])<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们将借助合并次序踪迹（slot）来跟踪合并的顺序。这个数字越小，表示合并的次序越靠后。这意味着，当我们想分拆聚类的时候，可以根据合并次序的值，从最小到最大依次进行。由于叶聚类不是合并而来的（这意味着无需分拆它们），因此，我们将它们合并次序的值规定为无穷大：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def get_merge_order(cluster):<br class="calibre12"/>    if is_leaf(cluster):<br class="calibre12"/>        return float('inf')<br class="calibre12"/>    else:<br class="calibre12"/>        return cluster[0]  # merge_order是二元组中的第一个元素<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">现在我们可以创建聚类算法了：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def bottom_up_cluster(inputs, distance_agg=min):<br class="calibre12"/>    # 最开始每个输入都是一个叶聚类/一元组<br class="calibre12"/>    clusters = [(input,) for input in inputs]<br class="calibre12"/><br class="calibre12"/>    # 只要剩余一个以上的聚类……<br class="calibre12"/>    while len(clusters) &gt; 1:<br class="calibre12"/>        # 就找出最近的两个聚类<br class="calibre12"/>        c1, c2 = min([(cluster1, cluster2)<br class="calibre12"/>                      for i, cluster1 in enumerate(clusters)<br class="calibre12"/>                      for cluster2 in clusters[:i]],<br class="calibre12"/>                      key=lambda (x, y): cluster_distance(x, y, distance_agg))<br class="calibre12"/><br class="calibre12"/>        # 从聚类列表中将它们移除<br class="calibre12"/>        clusters = [c for c in clusters if c != c1 and c != c2]<br class="calibre12"/><br class="calibre12"/>        # 使用merge_order = 剩余聚类的数目来合并它们<br class="calibre12"/>        merged_cluster = (len(clusters), [c1, c2])<br class="calibre12"/><br class="calibre12"/>        # 并添加它们的合并<br class="calibre12"/>        clusters.append(merged_cluster)<br class="calibre12"/><br class="calibre12"/>    # 当只剩一个聚类时，返回它<br class="calibre12"/>    return clusters[0]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">它的使用方法非常简单：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>base_cluster = bottom_up_cluster(inputs)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这将得到一个聚类，简单表示如下：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>(0, [(1, [(3, [(14, [(18, [([19, 28],),<br class="calibre12"/>                           ([21, 27],)]),<br class="calibre12"/>                     ([20, 23],)]),<br class="calibre12"/>               ([26, 13],)]),<br class="calibre12"/>          (16, [([11, 15],),<br class="calibre12"/>                ([13, 13],)])]),<br class="calibre12"/>    (2, [(4, [(5, [(9, [(11, [([-49, 0],),<br class="calibre12"/>                              ([-46, 5],)]),<br class="calibre12"/>                        ([-41, 8],)]),<br class="calibre12"/>                   ([-49, 15],)]),<br class="calibre12"/>              ([-34, -1],)]),<br class="calibre12"/>         (6, [(7, [(8, [(10, [([-22, -16],),<br class="calibre12"/>                              ([-19, -11],)]),<br class="calibre12"/>                        ([-25, -9],)]),<br class="calibre12"/>                   (13, [(15, [(17, [([-11, -6],),<br class="calibre12"/>                                     ([-12, -8],)]),<br class="calibre12"/>                               ([-14, -5],)]),<br class="calibre12"/>                         ([-18, -3],)])]),<br class="calibre12"/>              (12, [([-13, -19],),<br class="calibre12"/>                    ([-9, -16],)])])])])<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">对于每一个合并而来的聚类，我都会将其子聚类纵向连接。当我们说“0 号聚类”为合并次序为 0 的聚类时候，你可以将此理解为：</p><div class="calibre_5"> </div><ul class="calibre_6"><li value="1" class="calibre_7"><p class="calibre_">0 号聚类是由 1 号聚类和 2 号聚类合并得到的；</p></li><li value="2" class="calibre_8"><p class="calibre_">1 号聚类是由 3 号聚类和 16 号聚类合并得到的；</p></li><li value="3" class="calibre_8"><p class="calibre_">16 号聚类是由叶节点 <tt class="calibre7">[11, 15]</tt> 和叶节点 <tt class="calibre7">[13, 13]</tt> 合并得到的。</p></li><li value="4" class="calibre_8"><p class="calibre_">以此类推……</p></li></ul><p class="calibre_">因为我们有 20 个输入，所以只要经过 19 次合并，便能得到这个聚类。第一个合并而来的聚类是通过合并叶节点 <tt class="calibre7">[19, 28]</tt> 和叶节点 <tt class="calibre7">[21, 27]</tt> 得到的。而最后一个合并而来的聚类则是 0 号聚类。</p><p class="calibre_">但是，一般情况下我们不喜欢这种繁琐的文字表达方法。（不过话又说回来，对于创建一个用户友好型的可视化聚类分层结构，这也算是一个有趣的练习。）下面让我们来写一个函数，使其可以通过执行适当次数的分拆动作来产生任意数量的聚类：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def generate_clusters(base_cluster, num_clusters):<br class="calibre12"/>    # 开始的列表只有基本聚类<br class="calibre12"/>    clusters = [base_cluster]<br class="calibre12"/><br class="calibre12"/>    # 只要我们还没有足够的聚类……<br class="calibre12"/>    while len(clusters) &lt; num_clusters:<br class="calibre12"/>        # 选择上一个合并的聚类<br class="calibre12"/>        next_cluster = min(clusters, key=get_merge_order)<br class="calibre12"/>        # 将它从列表中移除<br class="calibre12"/>        clusters = [c for c in clusters if c != next_cluster]<br class="calibre12"/>        # 并将它的子聚累添加到列表中（即拆分它）<br class="calibre12"/>        clusters.extend(get_children(next_cluster))<br class="calibre12"/><br class="calibre12"/>    # 一旦我们有了足够的聚类……<br class="calibre12"/>    return clusters<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">举例来说，如果我们想要生成三个聚类，可以使用下列代码：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>three_clusters = [get_values(cluster)<br class="calibre12"/>                  for cluster in generate_clusters(base_cluster, 3)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">利用下面的代码，我们可以轻松绘制其图形：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>for i, cluster, marker, color in zip([1, 2, 3],<br class="calibre12"/>                                     three_clusters,<br class="calibre12"/>                                     ['D','o','*'],<br class="calibre12"/>                                     ['r','g','b']):<br class="calibre12"/>    xs, ys = zip(*cluster)  # 魔法般的解压方式<br class="calibre12"/>    plt.scatter(xs, ys, color=color, marker=marker)<br class="calibre12"/><br class="calibre12"/>    # 向聚类的均值添加一个数字<br class="calibre12"/>    x, y = vector_mean(cluster)<br class="calibre12"/>    plt.plot(x, y, marker='$' + str(i) + '$', color='black')<br class="calibre12"/><br class="calibre12"/>plt.title("利用最短距离得到的三个自下而上的聚类")<br class="calibre12"/>plt.xlabel("市中心以东的街区")<br class="calibre12"/>plt.ylabel("市中心以北的街区")<br class="calibre12"/>plt.show()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">与 <span class="italic">k</span> - 均值算法相比，我们得到了一个大不相同的结果，具体如图 19-6 所示。</p><p class="calibre_12"><img src="images/00013.jpg" class="calibre_144"/>
</p><p class="calibre_">
<span class="bold">图 19-6：利用最短距离得到的三个自下而上的聚类</span>
</p><p class="calibre_">正如我们上面提到的，这是因为在 <tt class="calibre7">cluster_distance</tt> 函数中使用参数 <tt class="calibre7">min</tt> 时往往会得到链状聚类。相反，如果我们使用参数 <tt class="calibre7">max</tt> （这能得到更加紧凑的聚类），将得到看上去与图 19-7 所示的 3-means 无异的结果。</p><p class="calibre_12"><img src="images/00026.jpg" class="calibre_145"/>
</p><p class="calibre_">
<span class="bold">图 19-7：利用最大距离得到的三个自下而上的聚类</span>
</p><blockquote class="calibre_14"><img src="images/00100.jpg" class="calibre_10"/> 　以上的 <tt class="calibre7">bottom_up_clustering</tt> 的实现代码相对来说已经很简单了，但是计算效率依然低得吓人。特别是，在每一步它都要重新计算每对输入之间的距离。更有效的实现方法是，预先算出每对输入之间的距离，然后在 cluster_distance 里面进行查找。一个真正高效的实现方法可能还需要存储上一步的 <tt class="calibre7">cluster_distance</tt> 。</blockquote><div class="mbp_pagebreak" id="calibre_pb_138"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
