<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos161841" class="calibre_"><span class="calibre6"><span class="bold"> 4.2　矩阵 </span></span></p><p class="calibre_">
<span class="bold">矩阵</span> 是一个二维的数据集合。我们将矩阵表示为列表的列表，每个内部列表的大小都一样，表示矩阵的<span class="bold">一行</span> 。如果 <tt class="calibre7">A</tt> 是一个矩阵，那么 <tt class="calibre7">A[i][j]</tt> 就表示第 <span class="italic">i</span> 行第 <span class="italic">j</span> 列的元素。按照数学表达的惯例，我们通常用大写字母表示矩阵。例如：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>A = [[1, 2, 3],   # A有2行3列<br class="calibre12"/>     [4, 5, 6]]<br class="calibre12"/><br class="calibre12"/>B = [[1, 2],      # B有3行2列<br class="calibre12"/>     [3, 4],<br class="calibre12"/>     [5, 6]]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><blockquote class="calibre_33"><img src="images/00100.jpg" class="calibre_10"/> 　在数学中，矩阵的第一行通常称为“第 1 行”，第一列通常称为“第 1 列”。而我们需要将矩阵的形式和 Python 的列表统一起来：Python 中的列表从 0 开始索引，所以，我们将矩阵的第一行称为“第 0 行”，将第一列称为“第 0 列”。</blockquote><p class="calibre_">基于列表的列表这种表达形式，矩阵 <tt class="calibre7">A</tt> 具有 <tt class="calibre7">len(A)</tt> 行和 <tt class="calibre7">len(A[0])</tt> 列，我们把这称作它的形状（<tt class="calibre7">shape</tt> ）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def shape(A):<br class="calibre12"/>    num_rows = len(A)<br class="calibre12"/>    num_cols = len(A[0]) if A else 0   # 第一行中元素的个数<br class="calibre12"/>    return num_rows, num_cols<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果一个矩阵有 <span class="italic">n</span> 行 <span class="italic">k</span> 列，则可以记为 <span class="italic">n</span> ×<span class="italic">k</span> 矩阵。我们可以把这个 <span class="italic">n</span> ×<span class="italic">k</span> 矩阵的每一行都当作一个长度为 <span class="italic">k</span> 的向量，把每一列都当作一个长度为 <span class="italic">n</span> 的向量：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def get_row(A, i):<br class="calibre12"/>    return A[i]              # A[i]是第i行<br class="calibre12"/><br class="calibre12"/>def get_column(A, j):<br class="calibre12"/>    return [A_i[j]           # 第A_i行的第j个元素<br class="calibre12"/>            for A_i in A]    # 对每个A_i行<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">同样，我们也可以根据形状和用来生成元素的函数来创建矩阵。可以通过一个嵌套的列表解析来实现：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def make_matrix(num_rows, num_cols, entry_fn):<br class="calibre12"/>    """returns a num_rows x num_cols matrix<br class="calibre12"/>    whose (i,j)th entry is entry_fn(i, j)"""<br class="calibre12"/>    return [[entry_fn(i, j)             # 根据i创建一个列表<br class="calibre12"/>             for j in range(num_cols)]  # [entry_fn(i, 0), ... ]<br class="calibre12"/>            for i in range(num_rows)]   # 为每一个i创建一个列表<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">有了这个函数，就可以生成一个 5×5 的<span class="bold">单位矩阵</span> （对角线元素是 1，其他元素是 0）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def is_diagonal(i, j):<br class="calibre12"/>    """1's on the 'diagonal', 0's everywhere else"""<br class="calibre12"/>    return 1 if i == j else 0<br class="calibre12"/><br class="calibre12"/>identity_matrix = make_matrix(5, 5, is_diagonal)<br class="calibre12"/><br class="calibre12"/># [[1, 0, 0, 0, 0],<br class="calibre12"/>#  [0, 1, 0, 0, 0],<br class="calibre12"/>#  [0, 0, 1, 0, 0],<br class="calibre12"/>#  [0, 0, 0, 1, 0],<br class="calibre12"/>#  [0, 0, 0, 0, 1]]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">矩阵的重要性不言而喻，原因有以下几个。</p><p class="calibre_">首先，可以通过将每个向量看成是矩阵的一行，来用矩阵表示一个包含多维向量的数据集。例如，如果有 1000 个人的身高、体重和年龄，就可以创建一个 1000×3 的矩阵：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>data = [[70, 170, 40],<br class="calibre12"/>        [65, 120, 26],<br class="calibre12"/>        [77, 250, 19],<br class="calibre12"/>        # ....<br class="calibre12"/>       ]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">第二，随后我们会看到，可以用一个 <span class="italic">n</span> ×<span class="italic">k</span> 矩阵表示一个线性函数，这个函数将一个 <span class="italic">k</span> 维的向量映射到一个 <span class="italic">n</span> 维的向量上。我们使用的很多技术与概念都隐含着这样的函数。</p><p class="calibre_">第三，可以用矩阵表示二维关系。在第 1 章中，我们曾经将网络边际表示为数据对 <tt class="calibre7">(i, j)</tt> 的集合。我们还可以通过建立矩阵 A 来实现这个描述：如果节点 <span class="italic">i</span> 和节点 <span class="italic">j</span> 有关系，则用矩阵的元素 <tt class="calibre7">A[i][j]</tt> 为 1 来表示；若节点 <span class="italic">i</span> 和节点 <span class="italic">j</span> 没有关系，则用 <tt class="calibre7">A[i][j]</tt> 为 0 来表示。</p><p class="calibre_">回想前面讲过的关系：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>friendships = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4), (4, 5), (5, 6), (5, 7), (6, 8), (7, 8), (8, 9)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">可以通过矩阵形式再现：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>     #     用户 0 1 2 3 4 5 6 7 8 9<br class="calibre12"/>     #<br class="calibre12"/>friendships = [[0, 1, 1, 0, 0, 0, 0, 0, 0, 0], # 用户 0<br class="calibre12"/>               [1, 0, 1, 1, 0, 0, 0, 0, 0, 0], # 用户 1<br class="calibre12"/>               [1, 1, 0, 1, 0, 0, 0, 0, 0, 0], # 用户 2<br class="calibre12"/>               [0, 1, 1, 0, 1, 0, 0, 0, 0, 0], # 用户 3<br class="calibre12"/>               [0, 0, 0, 1, 0, 1, 0, 0, 0, 0], # 用户 4<br class="calibre12"/>               [0, 0, 0, 0, 1, 0, 1, 1, 0, 0], # 用户 5<br class="calibre12"/>               [0, 0, 0, 0, 0, 1, 0, 0, 1, 0], # 用户 6<br class="calibre12"/>               [0, 0, 0, 0, 0, 1, 0, 0, 1, 0], # 用户 7<br class="calibre12"/>               [0, 0, 0, 0, 0, 0, 1, 1, 0, 1], # 用户 8<br class="calibre12"/>               [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]] # 用户 9<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果关系很少，这种表示形式的效率就会很低，因为必须存储很多零。但是，通过矩阵表示可以快速地查找确认某两个节点是否是连接的——通过一个矩阵查找函数即可，不必（有可能会）搜索每条边：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>friendships[0][2] == 1  # true，0和2是朋友<br class="calibre12"/>friendships[0][8] == 1  # false，0和8不是朋友<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">同样，若想找到一个节点的所有连接，只需检查这个节点所在的列（或行）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>friends_of_five = [i                                               # 仅需在<br class="calibre12"/>                   for i, is_friend in enumerate(friendships[5])   # 一行中<br class="calibre12"/>                   if is_friend]                                   # 查找<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">为了加速这个搜寻过程，我们之前给每个节点对象都添加了一个连接列表。但对于太大的、扩展性强的图形来说，成本太高，维护也很难。</p><p class="calibre_">本书随后还会探讨这些矩阵。</p><div class="mbp_pagebreak" id="calibre_pb_29"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
