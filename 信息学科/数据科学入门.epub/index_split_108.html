<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos473234" class="calibre_"><span class="calibre6"><span class="bold"> 15.7　回归系数的标准误差 </span></span></p><p class="calibre_">我们可以采用同样的方法来估计回归系数的标准误差。我们可以对数据重复采用 <tt class="calibre7">bootstrap_sample</tt> 样本，并根据这些样本估算 <tt class="calibre7">beta</tt> 。如果某个自变量（如 <tt class="calibre7">num_friends</tt> ）的系数在各个样本上变化不大，那么就可以确信我们的估计是比较严密的。如果这个系数随着样本的不同而起伏较大，那么我们就不能完全相信我们的估计。</p><p class="calibre_">唯一需要说明的是，采样前，我们需要把数据 <tt class="calibre7">X</tt> 和数据 <tt class="calibre7">Y</tt> 放到一起（用 <tt class="calibre7">zip</tt> ），以确保对自变量和因变量一起进行采样。这就意味着 <tt class="calibre7">bootstrap_sample</tt> 将返回一个由 <tt class="calibre7">(x_i, y_i)</tt> 数据对组成的列表，因此我们需要将其重新组合成一个 <tt class="calibre7">x_sample</tt> 和一个 <tt class="calibre7">y_sample</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def estimate_sample_beta(sample):<br class="calibre12"/>    """sample is a list of pairs (x_i, y_i)"""<br class="calibre12"/>    x_sample, y_sample = zip(*sample) # 魔法般的解压方式<br class="calibre12"/>    return estimate_beta(x_sample, y_sample)<br class="calibre12"/><br class="calibre12"/>random.seed(0) # 所以你得到的结果与我的一样<br class="calibre12"/><br class="calibre12"/>bootstrap_betas = bootstrap_statistic(zip(x, daily_minutes_good),<br class="calibre12"/>                                      estimate_sample_beta,<br class="calibre12"/>                                      100)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">之后，我们就可以估算每个系数的标准偏差了：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>bootstrap_standard_errors = [<br class="calibre12"/>    standard_deviation([beta[i] for beta in bootstrap_betas])<br class="calibre12"/>    for i in range(4)]<br class="calibre12"/><br class="calibre12"/># [1.174,    # 常数项，      实际误差 = 1.19<br class="calibre12"/>#  0.079,    # num_friends， 实际误差 = 0.080<br class="calibre12"/>#  0.131,    # unemployed,   实际误差 = 0.127<br class="calibre12"/>#  0.990]    # phd,          实际误差 = 0.998<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们可以使用它们来检验诸如“<span class="italic">β<sub class="calibre17"><small class="calibre9"><span class="calibre18"><span class="italic">i</span></span></small></sub>
</span> 等于 0 吗？”之类的假设。在满足 <span class="italic">β<sub class="calibre17"><small class="calibre9"><span class="calibre18"><span class="italic">i</span></span></small></sub>
</span> =0（以及与 <span class="italic">ε<sub class="calibre17"><small class="calibre9"><span class="calibre18"><span class="italic">i</span></span></small></sub>
</span> 分布 有关的其他假设）的条件下，则有：</p><p class="calibre_12"><img src="images/00055.jpg" class="calibre_116"/>
</p><p class="calibre_">也就是说，这个统计量等于我们估算的 <span class="italic">β<sub class="calibre17"><small class="calibre9"><span class="calibre18"><span class="italic">j</span></span></small></sub>
</span> 除以估算的其标准误差，它符合具有“<span class="italic">n</span> -<span class="italic">k</span> 个自由度”的<span class="bold">学生的 </span><span class="italic"><span class="bold">t</span></span><span class="bold"> 分布</span> （Student's t-distribution）。</p><p class="calibre_">如果我们有一个 <tt class="calibre7">students_t_cdf</tt> 函数，那么就可以计算每个最小二乘系数的 <span class="italic">p</span> 值，从而指出实际的系数为 0 时观察到这个值的可能性有多大。令人遗憾的是，实际上我们没有这样的函数。（虽然我们不想从头做起。）</p><p class="calibre_">然而，随着自由度变大，<span class="italic">t</span> 分布越接近标准正态分布。在这种情况下，即 <span class="italic">n</span> 比 <span class="italic">k</span> 大得多的情况下，我们便可以使用 <tt class="calibre7">normal_cdf</tt> 了，并且我们觉得它效果还不错：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def p_value(beta_hat_j, sigma_hat_j):<br class="calibre12"/>    if beta_hat_j &gt; 0:<br class="calibre12"/>        # 如果系数是正的，则我们需要对<br class="calibre12"/>        # 看见一个更大的值的概率做两次计算<br class="calibre12"/>        return 2 * (1 - normal_cdf(beta_hat_j / sigma_hat_j))<br class="calibre12"/>    else:<br class="calibre12"/>        # 否则看见一个更小值的概率乘以2<br class="calibre12"/>        return 2 * normal_cdf(beta_hat_j / sigma_hat_j)<br class="calibre12"/><br class="calibre12"/>p_value(30.63, 1.174)    # ~0   (常数项)<br class="calibre12"/>p_value(0.972, 0.079)    # ~0   (num_friends)<br class="calibre12"/>p_value(-1.868, 0.131)   # ~0   (work_hours)<br class="calibre12"/>p_value(0.911, 0.990)    # 0.36 (phd)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">（在其他情况下，我们很可能会使用一个知道如何计算 <span class="italic">t</span> 分布和精确的标准误差的统计软件。）</p><p class="calibre_">虽然大多数系数的 <span class="italic">p</span> 值都非常小（但非 0 值），但是“博士学位”的系数与零没有“显著”区别，也就是说“博士学位”的系数很可能是随机的，无意义的。</p><p class="calibre_">在对回归分析要求更加精细的情形下，你可能需要对数据的各种假设进行更加细致的测试，比如“至少有一个 <span class="italic">β<sub class="calibre17"><small class="calibre9"><span class="calibre18"><span class="italic">j</span></span></small></sub>
</span> 是非 0 值”，或者“<span class="italic">β</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">1</span></small></sub> 等于 <span class="italic">β</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">2</span></small></sub>
<span class="bold">且</span>
<span class="italic">β</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">3</span></small></sub> 等于 <span class="italic">β</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">4</span></small></sub> ”等，以便进行 <span class="italic">F</span> 测试，但是这些内容已经超出了本书的讨论范围。</p><div class="mbp_pagebreak" id="calibre_pb_108"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
