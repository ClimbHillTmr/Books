<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos73377" class="calibre_"><span class="calibre6"><span class="bold"> 2.1　基础内容 </span></span></p><p id="filepos73458" class="calibre_"><span class="calibre6"><span class="bold"> 2.1.1　Python获取 </span></span></p><p class="calibre_">可以从 python.org（<a href="https://www.python.org/" class="calibre3">https://www.python.org/</a> ）网站下载 Python。但是对于没有安装过 Python 的读者，特别推荐安装 Anaconda 版本（<a href="https://www.continuum.io/downloads" class="calibre3">https://www.continuum.io/downloads</a> ），这个版本涵盖了数据科学工作需要用到的大多数库。</p><p class="calibre_">当我写本书时，Python 的最新版本是 3.4。但是，在 DataSciencester，我们使用一个旧的可靠版本，Python 2.7。Python 3 无法向后兼容 Python 2，因此很多重要功能只能在 Python 2.7 上良好运行。数据科学社区中，2.7 版本一直是主流，我们也和它保持一致。请设法安装这个版本。</p><p class="calibre_">如果你没有 Anaconda 版本，那么需要安装 pip（<a href="https://pypi.python.org/pypi/pip" class="calibre3">https://pypi.python.org/pypi/pip</a> ），这是一个 Python 包管理器，可以用来方便地安装第三方包（其中有些是我们必需的）。IPython（<a href="http://ipython.org/" class="calibre3">http://ipython.org/</a> ）也不错，操作界面更友好。</p><p class="calibre_">（如果你已经安装了 Anaconda 版本，它会很好地和 pip 与 IPython 兼容。） 运行：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>pip install ipython<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果碰到难解的错误信息，可以在网上搜索解决办法。</p><p id="filepos75087" class="calibre_"><span class="calibre6"><span class="bold"> 2.1.2　Python之禅 </span></span></p><p class="calibre_">Python 的设计原则（<a href="http://legacy.python.org/dev/peps/pep-0020/" class="calibre3">http://legacy.python.org/dev/peps/pep-0020/</a> ）有着禅宗的意味，你输入 <span class="bold">
</span><tt class="calibre7"><span class="bold">import this</span></tt><span class="bold">
</span> 就能在 Python 解释器中一窥玄机。</p><p class="calibre_">讨论最多的原则之一是：</p><blockquote class="calibre_14">应该有一个——且最好只有一个——明显的方式去完成工作。</blockquote><p class="calibre_">按照这种“明显”的方式（对一个新人来说可能根本不明显）编写的代码常常被称为具有“Python 风格”。尽管本书不是专门介绍 Python 的书，但我们时不时地会比较 Python 风格和非 Python 风格的方式在解决相同问题时的差异，而且你常常会发现 Python 风格是更好的解决方式。</p><p id="filepos76042" class="calibre_"><span class="calibre6"><span class="bold"> 2.1.3　空白形式 </span></span></p><p class="calibre_">许多编程语言用大括号分隔代码块。Python 使用缩进的方式：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>for i in [1, 2, 3, 4, 5]:<br class="calibre12"/>    print i                    # "for i"程序块的第一行<br class="calibre12"/>    for j in [1, 2, 3, 4, 5]:<br class="calibre12"/>        print j                # "for j"程序块的第一行<br class="calibre12"/>        print i + j            # "for j"程序块的最后一行<br class="calibre12"/>    print i                    # "for i"程序块的最后一行<br class="calibre12"/>print "done looping"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这样会使 Python 代码非常易读，但这也意味着你需要非常小心格式。系统会省略方括号和圆括号中的空白，这对冗长的计算非常有用：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>long_winded_computation = (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">并能使代码更易读：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>list_of_lists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br class="calibre12"/><br class="calibre12"/>easier_to_read_list_of_lists = [ [1, 2, 3],<br class="calibre12"/>                                 [4, 5, 6],<br class="calibre12"/>                                 [7, 8, 9] ]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你可以用反斜线代表一个语句在下一行续写，尽管这个例子并不常见：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>two_plus_three = 2 + \<br class="calibre12"/>                 3<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">空白形式的一个后果是很难将代码复制并粘贴到 Python 的 shell。比如，如果你粘贴代码：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>for i in [1, 2, 3, 4, 5]:<br class="calibre12"/><br class="calibre12"/>    # 注意这个空行<br class="calibre12"/>    print i<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">在粘贴入一般的 Python shell 后，会得到以下提示：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>IndentationError: expected an indented block<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">因为解释器认为空行表示 <tt class="calibre7">for</tt> 循环的终结。</p><p class="calibre_">IPython 有一个奇妙的函数 <tt class="calibre7">%paste</tt> ，可以正确地复制剪贴板上的内容，包括空白在内。这个函数足以成为选择使用 IPython 的好理由。</p><p id="filepos79119" class="calibre_"><span class="calibre6"><span class="bold"> 2.1.4　模块 </span></span></p><p class="calibre_">Python 的某些特征默认不加载，包含了语言本身的部分特征，也包含了需读者自行下载的第三方特征。为了使用这些特征，你需要导入包含这些特征的模块。</p><p class="calibre_">一种方式是简单地导入模块本身：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import re<br class="calibre12"/>my_regex = re.compile("[0-9]+", re.I)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这里的 <tt class="calibre7">re</tt> 代表包含了处理正则表达式需要的函数与常量的模块。输入 <tt class="calibre7">import</tt> 之后，你可以通过加前缀 <tt class="calibre7">re.</tt> 来直接调用模块中的函数。</p><p class="calibre_">如果你的代码中已经有了不同的 <tt class="calibre7">re</tt> ，可以使用别名：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import re as regex<br class="calibre12"/>my_regex = regex.compile("[0-9]+", regex.I)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果模块名冗长，或者你需要敲很多字符，那不妨试试这个方法。比如，你想对数据用模块 <tt class="calibre7">matplotlib</tt> 来进行可视化，标准转换如下：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import matplotlib.pyplot as plt<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你需要一个模块中的一些特定值，可以显式导入，直接使用，不必提前获取权限，如下所示：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>from collections import defaultdict, Counter<br class="calibre12"/>lookup = defaultdict(int)<br class="calibre12"/>my_counter = Counter()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你是破坏者，可以将模块的全部内容导入命名空间，这也许会不加提示地覆盖原先定义的变量：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>match = 10<br class="calibre12"/>from re import *      # 呃，re有一个match函数<br class="calibre12"/>print match           # "&lt;function re.match&gt;"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">但是，不是破坏者就别这样做。</p><p id="filepos81540" class="calibre_"><span class="calibre6"><span class="bold"> 2.1.5　算法 </span></span></p><p class="calibre_">Python 2.7 默认整除，因此 <tt class="calibre7">5 / 2</tt> 等于 <tt class="calibre7">2</tt> 。但是这并不总是我们想要的，因此文件常常需要这样开始：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>from __future__ import division<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这样 <tt class="calibre7">5 / 2</tt> 等于 <tt class="calibre7">2.5</tt> 。本书中的所有示例程序采用新除法。在少数需要整除的情形下，我们可以通过双斜线 <tt class="calibre7">5 // 2</tt> 表示。</p><p id="filepos82170" class="calibre_"><span class="calibre6"><span class="bold"> 2.1.6　函数 </span></span></p><p class="calibre_">函数是一种规则，输入零或者其他数，得到相应的输出。在 Python 中，我们用 <tt class="calibre7">def</tt> 定义函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def double(x):<br class="calibre12"/>    """this is where you put an optional docstring<br class="calibre12"/>    that explains what the function does.<br class="calibre12"/>    for example, this function multiplies its input by 2"""<br class="calibre12"/>    return x * 2<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">Python 函数是<span class="bold">第一类函数</span> ，第一类函数意味着可以将它们赋给其他变量，也可以像其他参数一样传递给函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def apply_to_one(f):<br class="calibre12"/>    """calls the function f with 1 as its argument"""<br class="calibre12"/>    return f(1)<br class="calibre12"/><br class="calibre12"/>my_double = double             # 指向之前定义的函数<br class="calibre12"/>x = apply_to_one(my_double)    # 等于2<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">也很容易生成简短的匿名函数，或者 lambda：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>y = apply_to_one(lambda x: x + 4)     # 等于5<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你可以将 lambda 赋给变量，尽管大部分人会建议你用 <tt class="calibre7">def</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>another_double = lambda x: 2 * x      # 别这么做<br class="calibre12"/>def another_double(x): return 2 * x   # 要这么做<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">默认参数也可以赋值给函数参数，当你需要默认值以外的值时需要具体说明：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def my_print(message="my default message"):<br class="calibre12"/>    print message<br class="calibre12"/>my_print("hello")      # 打印"hello"<br class="calibre12"/>my_print()             # 打印"my default message"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">有时候通过名字指定参数会有用：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def subtract(a=0, b=0):<br class="calibre12"/>    return a - b<br class="calibre12"/><br class="calibre12"/>subtract(10, 5) # 返回5<br class="calibre12"/>subtract(0, 5)  # 返回-5<br class="calibre12"/>subtract(b=5)   # 和前一句一样<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们可以生成很多很多函数。</p><p id="filepos84958" class="calibre_"><span class="calibre6"><span class="bold"> 2.1.7　字符串 </span></span></p><p class="calibre_">字符串可以用单引号或者双引号标注分隔出来（但引号需要配对，即单引号对单引号，双引号对双引号）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>single_quoted_string = 'data science'<br class="calibre12"/>double_quoted_string = "data science"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">Python 用反斜线来为特殊字符编码。比如：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>tab_string = "\t"    # 表示tab字符<br class="calibre12"/>len(tab_string)      # 是1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你希望反斜线仅仅代表反斜线本身（你在 Windows 系统中的文件夹或者正则表达式中也许会遇到），那么可以使用命令 <tt class="calibre7">r""</tt> 生成一个<span class="bold">原始</span> 的字符串：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>not_tab_string = r"\t"    # 表示字符'\'和't'<br class="calibre12"/>len(not_tab_string)       # 是2<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你可以通过三重［两重］引号来生成多行的字符串：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>multi_line_string = """This is the first line.<br class="calibre12"/>and this is the second line<br class="calibre12"/>and this is the third line"""<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos86567" class="calibre_15"><span class="calibre6"><span class="bold"> 2.1.8　异常 </span></span></p><p class="calibre_">当发生意外时，Python 会报出<span class="bold">异常</span> 。如果不处理，异常会引起程序崩溃。你可以用 <tt class="calibre7">try</tt> 和 <tt class="calibre7">except</tt> 来解决：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>try:<br class="calibre12"/>    print 0 / 0<br class="calibre12"/>except ZeroDivisionError:<br class="calibre12"/>    print "cannot divide by zero"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">在许多语言中，异常意味着坏情形。但在 Python 中，你不必害怕遇见异常，只要能写出清晰的代码，我们时而会这样做。</p><p id="filepos87272" class="calibre_"><span class="calibre6"><span class="bold"> 2.1.9　列表 </span></span></p><p class="calibre_">Python 中最基本的数据结构是列表（<tt class="calibre7">list</tt> ）。一个列表是一个有序的集合。（这和其他语言中的数组概念类似，但增加了函数功能。）</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>integer_list = [1, 2, 3]<br class="calibre12"/>heterogeneous_list = ["string", 0.1, True]<br class="calibre12"/>list_of_lists = [ integer_list, heterogeneous_list, [] ]<br class="calibre12"/><br class="calibre12"/>list_length = len(integer_list)      # 等于3<br class="calibre12"/>list_sum    = sum(integer_list)      # 等于6<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你可以通过方括号对列表的第 <span class="italic">n</span> 个元素读值和赋值：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>x = range(10)   # 是列表[0, 1, ..., 9]<br class="calibre12"/>zero = x[0]     # 等于0，列表是0-索引的<br class="calibre12"/>one = x[1]      # 等于1<br class="calibre12"/>nine = x[-1]    # 等于9，最后一个元素的Python惯用法<br class="calibre12"/>eight = x[-2]   # 等于8，倒数第二个元素的Pyhton惯用法<br class="calibre12"/>x[0] = -1       # 现在x是[-1, 1, 2, 3, ..., 9]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你也可以用方括号来“切取”列表：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>first_three   = x[:3]              # [-1, 1, 2]<br class="calibre12"/>three_to_end = x[3:]               # [3, 4, ..., 9]<br class="calibre12"/>one_to_four = x[1:5]               # [1, 2, 3, 4]<br class="calibre12"/>last_three = x[-3:]                # [7, 8, 9]<br class="calibre12"/>without_first_and_last = x[1:-1]   # [1, 2, ..., 8]<br class="calibre12"/>copy_of_x = x[:]                   # [-1, 1, 2, ..., 9]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">Python 可以通过操作符 <tt class="calibre7">in</tt> 确认列表成员：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>1 in [1, 2, 3]    # True<br class="calibre12"/>0 in [1, 2, 3]    # False<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">确认每次都会遍历列表元素。这意味着除非列表很小，否则就不应该进行确认（除非你不在乎确认需要花费多长时间）。</p><p class="calibre_">将列表串连起来很容易：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>x = [1, 2, 3]<br class="calibre12"/>x.extend([4, 5, 6])   # x现在是[1,2,3,4,5,6]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果不希望改变原序列 <tt class="calibre7">x</tt> ，你可以使用列表加法：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>x = [1, 2, 3]<br class="calibre12"/>y = x + [4, 5, 6]    # y是[1, 2, 3, 4, 5, 6]；x是不变的<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">更常见的做法是，一次在原列表上只增加一项：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>x = [1, 2, 3]<br class="calibre12"/>x.append(0)       # x现在是[1, 2, 3, 0]<br class="calibre12"/>y = x[-1]         # 等于0<br class="calibre12"/>z = len(x)        # 等于4<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你知道列表中元素的个数，可以方便地从中<span class="bold">提取</span> 值：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>x, y = [1, 2]    # 现在x是1，y是2<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">不过，如果等式两端元素个数不同，会报出提示 <tt class="calibre7">ValueError</tt> 。</p><p class="calibre_">如果你希望忽略某些值，常见的选择是使用下划线：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>_, y = [1, 2]    # 现在y==2，不用关心第一个元素是什么<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos91479" class="calibre_15"><span class="calibre6"><span class="bold"> 2.1.10　元组 </span></span></p><p class="calibre_">元组是列表的亲表哥。你对列表做的很多操作都可以对元组做，但不包括修改。元组通过圆括号（或者什么都不加）而不是方括号来给出具体的描述：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>my_list = [1, 2]<br class="calibre12"/>my_tuple = (1, 2)<br class="calibre12"/>other_tuple = 3, 4<br class="calibre12"/>my_list[1] = 3     # my_list现在是[1, 3]<br class="calibre12"/><br class="calibre12"/>try:<br class="calibre12"/>    my_tuple[1] = 3<br class="calibre12"/>except TypeError:<br class="calibre12"/>    print "cannot modify a tuple"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">元组是通过函数返回多重值的便捷方法：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def sum_and_product(x, y):<br class="calibre12"/>    return (x + y),(x * y)<br class="calibre12"/><br class="calibre12"/>sp = sum_and_product(2, 3)     # 等于（5，6）<br class="calibre12"/>s, p = sum_and_product(5, 10)  # s是15，p是50<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">元组（和列表）都可以进行<span class="bold">多重赋值</span> （multiple assignment）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>x, y = 1, 2     # 现在x是1，y是2<br class="calibre12"/>x, y = y, x     # Python风格的互换变量，现在x是2，y是1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos92985" class="calibre_15"><span class="calibre6"><span class="bold"> 2.1.11　字典 </span></span></p><p class="calibre_">Python 中的另一种基本数据结构是字典，它将<span class="bold">值</span> 与<span class="bold">键</span> 联系起来，让我们可以通过键快速找到对应值：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>empty_dict = {}                         # Python风格<br class="calibre12"/>empty_dict2 = dict()                    # 更少的Python风格<br class="calibre12"/>grades = { "Joel" : 80, "Tim" : 95 }    # 字典<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你也可以通过方括号查找键的值：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>joels_grade = grades["Joel"]            # 等于80<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你找的键不在字典中，会得到 <tt class="calibre7">KeyError</tt> 报错：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>try:<br class="calibre12"/>    kates_grade = grades["Kate"]<br class="calibre12"/>except KeyError:<br class="calibre12"/>    print "no grade for Kate!"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你可以用 <tt class="calibre7">in</tt> 确认键的存在：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>joel_has_grade = "Joel" in grades     # 正确<br class="calibre12"/>kate_has_grade = "Kate" in grades     # 错误<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果查找的键在字典中不存在，字典可以通过方法 <tt class="calibre7">get</tt> 返回默认值（而非报出异常）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>joels_grade = grades.get("Joel", 0)   # 等于80<br class="calibre12"/>kates_grade = grades.get("Kate", 0)   # 等于0<br class="calibre12"/>no_ones_grade = grades.get("No One")  # 默认的默认值为None<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你可以通过方括号来为键值对赋值：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>grades["Tim"] = 99                    # 替换了旧的值<br class="calibre12"/>grades["Kate"] = 100                  # 增加了第三个记录<br class="calibre12"/>num_students = len(grades)            # 等于3<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们常常使用字典作为代表结构数据的简单方式：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>tweet = {<br class="calibre12"/>    "user" : "joelgrus",<br class="calibre12"/>    "text" : "Data Science is Awesome",<br class="calibre12"/>    "retweet_count" : 100,<br class="calibre12"/>    "hashtags" : ["#data", "#science", "#datascience", "#awesome", "#yolo"]<br class="calibre12"/>}<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">除了查找特定的键，我们还可以查找所有值：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>tweet_keys   = tweet.keys()      # 键的列表<br class="calibre12"/>tweet_values = tweet.values()    # 值的列表<br class="calibre12"/>tweet_items  = tweet.items()     # （键, 值）元组的列表<br class="calibre12"/><br class="calibre12"/>"user" in tweet_keys             # True，使用慢速的列表<br class="calibre12"/>"user" in tweet                  # 更符合Python惯用法，使用快速的字典<br class="calibre12"/>"joelgrus" in tweet_values       # True<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">字典的键不可改变，尤其是不能将列表作为键。如果你需要一个多维的键，应该使用元组或设法把键转换成字符串。</p><p class="calibre_">1. <tt class="calibre7">defaultdict</tt>
</p><p class="calibre_">假设你需要计算某份文件中的单词数目。一个明显的方式是，建立一个键是单词、值是单词出现次数的字典。每次你查到一个单词，如果字典中存在这个词，就在该词的计数上增加 1，如果字典中没有这个词，就把这个词增加到这个字典中：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>word_counts = {}<br class="calibre12"/>for word in document:<br class="calibre12"/>    if word in word_counts:<br class="calibre12"/>        word_counts[word] += 1<br class="calibre12"/>    else:<br class="calibre12"/>        word_counts[word] = 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">当查找缺失值碰到异常报出时，你可以遵循“与其瞻前顾后，不如果断行动”（Forgiveness is better than permission）的原则，果断处理异常：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>word_counts = {}<br class="calibre12"/>for word in document:<br class="calibre12"/>    try:<br class="calibre12"/>        word_counts[word] += 1<br class="calibre12"/>    except KeyError:<br class="calibre12"/>        word_counts[word] = 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">第三种方法是使用 <tt class="calibre7">get</tt> ，这种处理缺失值的方法比较优雅：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>word_counts = {}<br class="calibre12"/>for word in document:<br class="calibre12"/>    previous_count = word_counts.get(word, 0)<br class="calibre12"/>    word_counts[word] = previous_count + 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">以上三种方法都略显笨拙，这是 <tt class="calibre7">defaultdict</tt> 的意义之所在。一个 <tt class="calibre7">defaultdict</tt> 相当于一个标准的字典，除了当你查找一个没有包含在内的键时，它用一个你提供的零参数函数建立一个新的键，并为它的值增加 1。为了使用 <tt class="calibre7">defaultdict</tt> ，你需要将其从集合中导出：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>from collections import defaultdict<br class="calibre12"/><br class="calibre12"/>word_counts = defaultdict(int)             # int()生成0<br class="calibre12"/><br class="calibre12"/>for word in document:<br class="calibre12"/>    word_counts[word] += 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这对列表、字典或者你自己的函数都有用：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>dd_list = defaultdict(list)              # list()生成一个空列表<br class="calibre12"/>dd_list[2].append(1)                     # 现在dd_list包含{2:[1]}<br class="calibre12"/><br class="calibre12"/>dd_dict = defaultdict(dict)              # dict()产生一个新字典<br class="calibre12"/>dd_dict["Joel"]["City"] = "Seattle"      # { "Joel" : { "City" : Seattle"}}<br class="calibre12"/><br class="calibre12"/>dd_pair = defaultdict(lambda: [0, 0])<br class="calibre12"/>dd_pair[2][1] = 1                        # 现在dd_pair包含{2: [0,1]}<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">当我们用字典“收集”某些键对应的结果，并且不希望每次查找某键是否存在都遍历一遍的时候，<tt class="calibre7">defaultdict</tt> 非常有用。</p><p class="calibre_">2. <tt class="calibre7">Counter</tt>
</p><p class="calibre_">一个计数器将一个序列的值转化成一个类似于整型的标准字典（即 <tt class="calibre7">defaultdict(int)</tt> ）的键到计数的对象映射。我们主要用它来生成直方图：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>from collections import Counter<br class="calibre12"/>c = Counter([0, 1, 2, 0])         # c是（基本的） { 0 : 2, 1 : 1, 2 : 1 }<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这给我们提供了一个用来解决单词计数问题的很简便的方法：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>word_counts = Counter(document)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">一个 <tt class="calibre7">Counter</tt> 实例带有的 <tt class="calibre7">most_common</tt> 方法的例子如下：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 打印10个最常见的词和它们的计数<br class="calibre12"/>for word, count in word_counts.most_common(10):<br class="calibre12"/>    print word, count<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos101450" class="calibre_15"><span class="calibre6"><span class="bold"> 2.1.12　集合 </span></span></p><p class="calibre_">另一种数据结构是集合（<tt class="calibre7">set</tt> ），它表示为一组<span class="bold">不同</span> 的元素：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>s = set()<br class="calibre12"/>s.add(1)         # s现在是1<br class="calibre12"/>s.add(2)         # s现在是{1,2}<br class="calibre12"/>s.add(2)         # s还是{1,2}<br class="calibre12"/>x = len(s)       # 等于2<br class="calibre12"/>y = 2 in s       # 等于True<br class="calibre12"/>z = 3 in s       # 等于False<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们使用集合的原因主要有两个。第一个是集合上有一种非常快速的操作：<tt class="calibre7">in</tt> 。如果我们有大量的项目，希望对它的成分进行测试，那么使用集合比使用列表要合适得多：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>stopwords_list = ["a","an","at"] + hundreds_of_other_words + ["yet", "you"]<br class="calibre12"/>"zip" in stopwords_list     # False，但需要检查每个元素<br class="calibre12"/><br class="calibre12"/>stopwords_set = set(stopwords_list)<br class="calibre12"/>"zip" in stopwords_set      # 非常快地检查<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">第二个原因是便于在一个汇总中寻找其中<span class="bold">离散</span> 的项目：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>item_list = [1, 2, 3, 1, 2, 3]<br class="calibre12"/>num_items = len(item_list)            # 6<br class="calibre12"/>item_set = set(item_list)             # {1, 2, 3}<br class="calibre12"/>num_distinct_items = len(item_set)    # 3<br class="calibre12"/>distinct_item_list = list(item_set)   # [1, 2, 3]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们使用 <tt class="calibre7">set</tt> 的频率要远低于 <tt class="calibre7">dict</tt> 和 <tt class="calibre7">list</tt> 。</p><p id="filepos103422" class="calibre_"><span class="calibre6"><span class="bold"> 2.1.13　控制流 </span></span></p><p class="calibre_">和大多数编程语言一样，你可以用 <tt class="calibre7">if</tt> 语句来执行一种有条件的行动：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>if 1 &gt; 2:<br class="calibre12"/>    message = "if only 1 were greater than two..."<br class="calibre12"/>elif 1 &gt; 3:<br class="calibre12"/>    message = "elif stands for 'else if'"<br class="calibre12"/>else:<br class="calibre12"/>    message = "when all else fails use else (if you want to)"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">也可以在一行语句中使用 if-then-else，我们有时候需要这么做：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>parity = "even" if x % 2 == 0 else "odd"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">Python 也有 <tt class="calibre7">while</tt> 循环：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>x = 0<br class="calibre12"/>while x &lt; 10:<br class="calibre12"/>    print x, "is less than 10"<br class="calibre12"/>    x += 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">尽管我们更常用 <tt class="calibre7">for</tt> 和 <tt class="calibre7">in</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>for x in range(10):<br class="calibre12"/>    print x, "is less than 10"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你需要更复杂的逻辑表达式，可以使用 <tt class="calibre7">continue</tt> 和 <tt class="calibre7">break</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>for x in range(10):<br class="calibre12"/>    if x == 3:<br class="calibre12"/>        continue        # 直接进入下次迭代<br class="calibre12"/>    if x == 5:<br class="calibre12"/>        break           # 完全退出循环<br class="calibre12"/>    print x<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">上面的语句会打印 <tt class="calibre7">0</tt> 、<tt class="calibre7">1</tt> 、<tt class="calibre7">2</tt> 和 <tt class="calibre7">4</tt> 。</p><p id="filepos105534" class="calibre_"><span class="calibre6"><span class="bold"> 2.1.14　真和假 </span></span></p><p class="calibre_">Python 的布尔数除了首字母大写之外，其他用法和大多数别的语言类似：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>one_is_less_than_two = 1 &lt; 2        # 等于True<br class="calibre12"/>true_equals_false = True == False   # 等于False<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">Python 使用 <tt class="calibre7">None</tt> 来表示一个不存在的值，它类似别的语言中的 <tt class="calibre7">null</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>x = None<br class="calibre12"/>print x == None    # 打印True，但这并非Python的惯用法<br class="calibre12"/>print x is None    # 打印True，符合Python的惯用法<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">Python 可以使用任何可被认为是布尔数的值。下面这些都是“假”（Falsy）：</p><div class="calibre_5"> </div><ul class="calibre_6"><li value="1" class="calibre_7"><p class="calibre_">
<tt class="calibre7">False</tt>
</p></li><li value="2" class="calibre_8"><p class="calibre_">
<tt class="calibre7">None</tt>
</p></li><li value="3" class="calibre_8"><p class="calibre_">
<tt class="calibre7">[ ]</tt> （一个空 <tt class="calibre7">list</tt> ）</p></li><li value="4" class="calibre_8"><p class="calibre_">
<tt class="calibre7">{ }</tt> （一个空 <tt class="calibre7">dict</tt> ）</p></li><li value="5" class="calibre_8"><p class="calibre_">
<tt class="calibre7">""</tt>
</p></li><li value="6" class="calibre_8"><p class="calibre_">
<tt class="calibre7">set()</tt>
</p></li><li value="7" class="calibre_8"><p class="calibre_">
<tt class="calibre7">0</tt>
</p></li><li value="8" class="calibre_8"><p class="calibre_">
<tt class="calibre7">0.0</tt>
</p></li></ul><p class="calibre_">还有很多值可作为真（<tt class="calibre7">True</tt> ）来处理。这样你可以很容易地使用 <tt class="calibre7">if</tt> 语句来对空列表、空字符串或空字典等进行测试。有时候，如果你没有意识到这种行为，会引入一些微妙的 bug：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>s = some_function_that_returns_a_string()<br class="calibre12"/>if s:<br class="calibre12"/>    first_char = s[0]<br class="calibre12"/>else:<br class="calibre12"/>    first_char = ""<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">另一种简单的方法是：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>first_char = s and s[0]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这是因为第一个值为“真”时，<tt class="calibre7">and</tt> 运算符返回它的第二个值，否则返回第一个值。类似地，如果 <tt class="calibre7">x</tt> 的取值可能是一个数也可能是 <tt class="calibre7">None</tt> ，那么以下代码的结果就必然会是一个数字：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>safe_x = x or 0<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">Python 还有一个 <tt class="calibre7">all</tt> 函数，它的取值是一个列表，当列表的每个元素都为真时返回 <tt class="calibre7">True</tt> 。</p><p class="calibre_">Python 还有一个 <tt class="calibre7">any</tt> 函数，当取值的列表中至少有一个元素为真时，它返回 <tt class="calibre7">True</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>all([True, 1, { 3 }])    # True<br class="calibre12"/>all([True, 1, {}])       # False，{}为假<br class="calibre12"/>any([True, 1, {}])       # True<br class="calibre12"/>all([])                  # True，列表里没有假的元素<br class="calibre12"/>any([])                  # False，列表里没有真的元素<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><div class="mbp_pagebreak" id="calibre_pb_18"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
