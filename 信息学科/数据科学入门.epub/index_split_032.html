<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos172214" class="calibre_"><span class="calibre6"><span class="bold"> 5.1　描述单个数据集 </span></span></p><p class="calibre_">凭借口碑与运气，DataSciencester 已经发展了数十名成员。这时，融资部门的副总来问你要一些关于你的成员有多少朋友的描述，以此来确定他潜在的电梯演说对象。</p><p class="calibre_">运用第 1 章中学到的技术可以很容易地生成这个数据。但你现面临的问题是如何<span class="bold">描述</span> 它。</p><p class="calibre_">对任何数据集，最简单的描述方法就是数据本身：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>num_friends = [100, 49, 41, 40, 25,<br class="calibre12"/>               # ……等等许多<br class="calibre12"/>              ]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">对足够小的数据集来说，这甚至可以说是最好的描述方法。但随着数据规模变大，这就显得笨拙又含混了。（想象一个包含一亿个数字的列表。）为此，我们使用统计来提炼和表达数据的相关特征。</p><p class="calibre_">首先，我们通过 <tt class="calibre7">Couner</tt> 和 <tt class="calibre7">plt.bar()</tt> 把你的朋友数绘成直方图（图 5-1）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>friend_counts = Counter(num_friends)<br class="calibre12"/>xs = range(101)                       # 最大值是100<br class="calibre12"/>ys = [friend_counts[x] for x in xs]   # height刚好是朋友的个数<br class="calibre12"/>plt.bar(xs, ys)<br class="calibre12"/>plt.axis([0, 101, 0, 25])<br class="calibre12"/>plt.title("朋友数的直方图")<br class="calibre12"/>plt.xlabel("朋友个数")<br class="calibre12"/>plt.ylabel("人数")<br class="calibre12"/>plt.show()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_19"><img src="images/00017.jpg" class="calibre_35"/>
</p><p class="calibre_">
<span class="bold">图 5-1：朋友数的直方图</span>
</p><p class="calibre_">不幸的是，这幅图难以用来进行交流，所以你需要再提炼一些统计量。数据点个数大概就是最简单的统计量了：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>num_points = len(num_friends)             # 204<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">也许你会对数据集的最大值和最小值感兴趣：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>largest_value = max(num_friends)          # 100<br class="calibre12"/>smallest_value = min(num_friends)         # 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你想知道特定位置的值，可以这样做：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>sorted_values = sorted(num_friends)<br class="calibre12"/>smallest_value = sorted_values[0]         # 1<br class="calibre12"/>second_smallest_value = sorted_values[1]  # 1<br class="calibre12"/>second_largest_value = sorted_values[-2]  # 49<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">当然，这仅仅是开始。</p><p id="filepos175437" class="calibre_"><span class="calibre6"><span class="bold"> 5.1.1　中心倾向 </span></span></p><p class="calibre_">我们常常希望了解数据中心位置的一些概念。一个常用的方法是使用<span class="bold">均值</span> （mean 或 average），即用数据和除以数据个数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 如果没有从__future__导入division，那就是不对的<br class="calibre12"/>def mean(x):<br class="calibre12"/>    return sum(x) / len(x)<br class="calibre12"/><br class="calibre12"/>mean(num_friends)   # 7.333333<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你有两个数据点，均值就意味着两点的中间点。随着数据集中点数的增加，均值点会移动，但它始终取决于每个点的取值。</p><p class="calibre_">我们常常也会用到<span class="bold">中位数</span> （median），它是指数据中间点的值（如果数据点的个数是奇数），或者中间两个点的平均值（如果数据点的个数是偶数）。</p><p class="calibre_">例如，如果在排序向量 <tt class="calibre7">x</tt> 上有五个数据点，那么中位数就是 <tt class="calibre7">x[5 // 2]</tt> 或 <tt class="calibre7">x[2]</tt> 。如果有六个数据点，则中位数是 <tt class="calibre7">x[2]</tt> （第三个点）与 <tt class="calibre7">x[3]</tt> （第四个点）的平均数。</p><p class="calibre_">注意——和均值不同——中位数并不依赖于每一个数据的值。例如，即便数据集中最大的点变得更大（或最小的点变得更小），中间的数据点都不会变，意味着中位数也不会变。</p><p class="calibre_">
<tt class="calibre7">median</tt> 函数很可能比你想象的更复杂一些，主要是因为数据集中数据个数奇偶性的不同：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def median(v):<br class="calibre12"/>    """finds the 'middle-most' value of v"""<br class="calibre12"/>    n = len(v)<br class="calibre12"/>    sorted_v = sorted(v)<br class="calibre12"/>    midpoint = n // 2<br class="calibre12"/><br class="calibre12"/>    if n % 2 == 1:<br class="calibre12"/>        # 如果是奇数，返回中间值<br class="calibre12"/>        return sorted_v[midpoint]<br class="calibre12"/>    else:<br class="calibre12"/>        # 如果是偶数，返回中间两个值的均值<br class="calibre12"/>        lo = midpoint - 1<br class="calibre12"/>        hi = midpoint<br class="calibre12"/>        return (sorted_v[lo] + sorted_v[hi]) / 2<br class="calibre12"/>        median(num_friends) # 6.0<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">很明显，均值的计算更简单，并且它会随着数据变化而平稳地变化。如果有 <span class="italic">n</span> 个数据点，其中某一个点的值增加了 <span class="italic">e</span> ，则均值随之增加 <span class="italic">e</span> /<span class="italic">n</span> 。（这使得均值适用于各种微分运算）但是为了计算中位数，得先对数据排序。并且，如果其中一个数据点的值增加了 <span class="italic">e</span> ，那么中位数有可能也增加 <span class="italic">e</span> ，有可能增加一个小于 <span class="italic">e</span> 的数，也有可能根本不变（这取决于其他的数据）。</p><blockquote class="calibre_14"><img src="images/00100.jpg" class="calibre_10"/> 　事实上，不排序也可以使用一些生僻的技巧有效地算出中位数（<a href="https://en.wikipedia.org/wiki/Quickselect" class="calibre3">https://en.wikipedia.org/wiki/Quickselect</a> ）。但这些技巧不但不易理解，而且超出了本书的讲解范围。所以我们先排序再计算。</blockquote><p class="calibre_">同时，均值对数据中的异常值非常敏感。如果最具人缘的用户有 200 个朋友（不是 100），均值会上升至 7.82，而中位数不变。如果异常值属于不良数据（或者对我们试图理解的现象不具有代表性），那么均值会误导我们。举一个老生常谈的例子，20 世纪 80 年代，北卡罗来纳大学起薪最高的专业是地理学，因为球星迈克尔 · 乔丹曾就读于此，均值计算就包含了这个“异常值”。</p><p class="calibre_">中位数的一个泛化概念是<span class="bold">分位数</span> （quantile），它表示少于数据中特定百分比的一个值。（中位数表示少于 50% 的数据的一个值。)</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def quantile(x, p):<br class="calibre12"/>    """returns the pth-percentile value in x"""<br class="calibre12"/>    p_index = int(p * len(x))<br class="calibre12"/>    return sorted(x)[p_index]<br class="calibre12"/><br class="calibre12"/>quantile(num_friends, 0.10) # 1<br class="calibre12"/>quantile(num_friends, 0.25) # 3<br class="calibre12"/>quantile(num_friends, 0.75) # 9<br class="calibre12"/>quantile(num_friends, 0.90) # 13<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">还有一个不太常用的概念<span class="bold">众数</span> （mode），它是指出现次数最多的一个或多个数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def mode(x):<br class="calibre12"/>    """returns a list, might be more than one mode"""<br class="calibre12"/>    counts = Counter(x)<br class="calibre12"/>    max_count = max(counts.values())<br class="calibre12"/>    return [x_i for x_i, count in counts.iteritems()<br class="calibre12"/>            if count == max_count]<br class="calibre12"/><br class="calibre12"/>mode(num_friends)       # 1 和 6<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">但是，最常用的还是均值。</p><p id="filepos180844" class="calibre_"><span class="calibre6"><span class="bold"> 5.1.2　离散度 </span></span></p><p class="calibre_">
<span class="bold">离散度</span> 是数据的离散程度的一种度量。通常，如果它所统计的值接近零，则表示数据聚集在一起，<span class="bold">离散程度很小</span> ，如果值很大（无论那意味着什么），则表示数据的<span class="bold">离散度很大</span> 。例如，一个简单的度量是<span class="bold">极差</span> （range），指最大元素与最小元素的差：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># "range" 在Python中已经有特定的含义，所以我们换一个不同的名字<br class="calibre12"/>def data_range(x):<br class="calibre12"/>    return max(x) - min(x)<br class="calibre12"/><br class="calibre12"/>data_range(num_friends) # 99<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">极差恰好为零，意味着数据集中最大值和最小值相等，这种情形只有在 <tt class="calibre7">x</tt> 中的元素全部相同时才会发生，意味着数据没有离散。相反，如果极差很大，说明最大元素比最小元素大很多，数据离散度很高。</p><p class="calibre_">和中位数一样，极差也不真正依赖于整个数据集。一个只包含 0 和 100 的数据集，和一个包含 0、1 以及很多个 50 的数据集，两者的极差相同。但看起来第一个数据集的离散度“应该”更高。</p><p class="calibre_">离散度的另一个更复杂的度量是<span class="bold">方差</span> （variance），计算方式如下：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def de_mean(x):<br class="calibre12"/>    """translate x by subtracting its mean (so the result has mean 0)"""<br class="calibre12"/>    x_bar = mean(x)<br class="calibre12"/>    return [x_i - x_bar for x_i in x]<br class="calibre12"/><br class="calibre12"/>def variance(x):<br class="calibre12"/>    """assumes x has at least two elements"""<br class="calibre12"/>    n = len(x)<br class="calibre12"/>    deviations = de_mean(x)<br class="calibre12"/>    return sum_of_squares(deviations) / (n - 1)<br class="calibre12"/><br class="calibre12"/>variance(num_friends) # 81.54<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><blockquote class="calibre_33"><img src="images/00100.jpg" class="calibre_10"/> 　这个概念看起来似乎是各个数值分别与其均值之差的平方的均值，但我们除以的是 <tt class="calibre7">n-1</tt> 而不是 <tt class="calibre7">n</tt> 。事实上，如果样本取自更大的总体，<tt class="calibre7">x_bar</tt> 就是真实均值的估值，意味着 <tt class="calibre7">(x_i - x_bar) ** 2</tt> 是 <tt class="calibre7">x_i</tt> 的方差对均值的低估值，所以我们除以 <tt class="calibre7">n-1</tt> 而不是 <tt class="calibre7">n</tt> 。更多信息请查看维基百科。</blockquote><p class="calibre_">现在，无论我们的数据是什么单位（即“朋友”），所有中心倾向的度量都是同一单位。极差的单位也与此相同。但是，方差的单位是原数据单位的<span class="bold">平方</span> （即“平方朋友”）。然而，用方差很难给出直观的比较，所以我们更常使用<span class="bold">标准差</span> （standard deviation）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def standard_deviation(x):<br class="calibre12"/>    return math.sqrt(variance(x))<br class="calibre12"/><br class="calibre12"/>standard_deviation(num_friends) # 9.03<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">极差和标准差也都有我们之前提到的均值计算常遇到的异常值问题。再看之前的例子，如果我们最具人缘的用户有 200 个朋友，标准差就变为 14.89，增加了 60% ！</p><p class="calibre_">一种更加稳健的方案是计算 75% 的分位数和 25% 的分位数之差：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def interquartile_range(x):<br class="calibre12"/>    return quantile(x, 0.75) - quantile(x, 0.25)<br class="calibre12"/><br class="calibre12"/>interquartile_range(num_friends) # 6<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">相对来说，这种计算不易受到一小部分异常值的影响。</p><div class="mbp_pagebreak" id="calibre_pb_32"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
