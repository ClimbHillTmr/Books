<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos692398" class="calibre_"><span class="calibre6"><span class="bold"> 22.4　基于物品的协同过滤算法 </span></span></p><p class="calibre_">还有一种方法，即直接计算两种兴趣之间的相似度，然后将与用户当前兴趣相似的兴趣放到一起，并从中为用户推荐感兴趣的东西。</p><p class="calibre_">首先，我们要对用户兴趣矩阵进行<span class="bold">转置</span> （transpose），以使行对应于兴趣，列对应于用户：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>interest_user_matrix = [[user_interest_vector[j]<br class="calibre12"/>                         for user_interest_vector in user_interest_matrix]<br class="calibre12"/>                        for j, _ in enumerate(unique_interests)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这么做之后，结果如何呢？这时，矩阵 <tt class="calibre7">interest_user_matrix</tt> 的行 <tt class="calibre7">j</tt> 就是矩阵 <tt class="calibre7">user_interest_matrix</tt> 的列 <tt class="calibre7">j</tt> 。也就是说，1 表示用户有某种兴趣，0 表示用户没有某种兴趣。</p><p class="calibre_">举例来说，假设 <tt class="calibre7">unique_interests[0]</tt> 为 Big Data，那么 <tt class="calibre7">interest_user_matrix[0]</tt> 则为：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这是因为用户 0、8 和 9 都对 Big Data 感兴趣。</p><p class="calibre_">现在，我们可以再次利用余弦相似度。如果喜欢两个主题的用户完全重合，那么它们的相似度为 1。如果喜欢两个主题的用户没有一个是重合的，那么它们的相似度将是 0：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>interest_similarities = [[cosine_similarity(user_vector_i, user_vector_j)<br class="calibre12"/>                          for user_vector_j in interest_user_matrix]<br class="calibre12"/>                         for user_vector_i in interest_user_matrix]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">例如，我们可以通过下列代码找出与 Big Data（兴趣 0）最相似的项：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def most_similar_interests_to(interest_id):<br class="calibre12"/>    similarities = interest_similarities[interest_id]<br class="calibre12"/>    pairs = [(unique_interests[other_interest_id], similarity)<br class="calibre12"/>             for other_interest_id, similarity in enumerate(similarities)<br class="calibre12"/>             if interest_id != other_interest_id and similarity &gt; 0]<br class="calibre12"/>    return sorted(pairs,<br class="calibre12"/>                  key=lambda (_, similarity): similarity,<br class="calibre12"/>                  reverse=True)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">下面是推荐的相似兴趣：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>[('Hadoop', 0.8164965809277261),<br class="calibre12"/> ('Java', 0.6666666666666666),<br class="calibre12"/> ('MapReduce', 0.5773502691896258),<br class="calibre12"/> ('Spark', 0.5773502691896258),<br class="calibre12"/> ('Storm', 0.5773502691896258),<br class="calibre12"/> ('Cassandra', 0.4082482904638631),<br class="calibre12"/> ('artificial intelligence', 0.4082482904638631),<br class="calibre12"/> ('deep learning', 0.4082482904638631),<br class="calibre12"/> ('neural networks', 0.4082482904638631),<br class="calibre12"/> ('HBase', 0.3333333333333333)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">现在，我们可以通过总结与其兴趣相似的东西来为其提供建议：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def item_based_suggestions(user_id, include_current_interests=False):<br class="calibre12"/>    # 将相似的兴趣相加<br class="calibre12"/>    suggestions = defaultdict(float)<br class="calibre12"/>    user_interest_vector = user_interest_matrix[user_id]<br class="calibre12"/>    for interest_id, is_interested in enumerate(user_interest_vector):<br class="calibre12"/>        if is_interested == 1:<br class="calibre12"/>            similar_interests = most_similar_interests_to(interest_id)<br class="calibre12"/>            for interest, similarity in similar_interests:<br class="calibre12"/>                suggestions[interest] += similarity<br class="calibre12"/><br class="calibre12"/># 根据权重将其排序<br class="calibre12"/>suggestions = sorted(suggestions.items(),<br class="calibre12"/>                     key=lambda (_, similarity): similarity,<br class="calibre12"/>                     reverse=True)<br class="calibre12"/><br class="calibre12"/>if include_current_interests:<br class="calibre12"/>    return suggestions<br class="calibre12"/>else:<br class="calibre12"/>    return [(suggestion, weight)<br class="calibre12"/>            for suggestion, weight in suggestions<br class="calibre12"/>            if suggestion not in users_interests[user_id]]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">下面是为用户 0 提供的（看上去比较恰当的）建议：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>[('MapReduce', 1.861807319565799),<br class="calibre12"/> ('Postgres', 1.3164965809277263),<br class="calibre12"/> ('MongoDB', 1.3164965809277263),<br class="calibre12"/> ('NoSQL', 1.2844570503761732),<br class="calibre12"/> ('programming languages', 0.5773502691896258),<br class="calibre12"/> ('MySQL', 0.5773502691896258),<br class="calibre12"/> ('Haskell', 0.5773502691896258),<br class="calibre12"/> ('databases', 0.5773502691896258),<br class="calibre12"/> ('neural networks', 0.4082482904638631),<br class="calibre12"/> ('deep learning', 0.4082482904638631),<br class="calibre12"/> ('C++', 0.4082482904638631),<br class="calibre12"/> ('artificial intelligence', 0.4082482904638631),<br class="calibre12"/> ('Python', 0.2886751345948129),<br class="calibre12"/> ('R', 0.2886751345948129)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><div class="mbp_pagebreak" id="calibre_pb_156"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
