<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos264415" class="calibre_"><span class="calibre6"><span class="bold"> 8.2　估算梯度 </span></span></p><p class="calibre_">如果 <tt class="calibre7">f</tt> 是单变量函数，那么它在 <tt class="calibre7">x</tt> 点的导数衡量了当 <tt class="calibre7">x</tt> 发生变化时，<tt class="calibre7">f(x)</tt> 变化了多少。导数通过差商的极限来定义：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def difference_quotient(f, x, h):<br class="calibre12"/>    return (f(x + h) - f(x)) / h<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">其中 <tt class="calibre7">h</tt> 趋近于 0。</p><p class="calibre_">（许多微积分初学者常常受困于极限的数学定义。这里我们不妨说，你认为它是什么，它就是什么。）</p><p class="calibre_12"><img src="images/00009.jpg" class="calibre_74"/>
</p><p class="calibre_">
<span class="bold">图 8-2：通过差商来求近似导数</span>
</p><p class="calibre_">导数就是在点 (<span class="italic">x</span> , <span class="italic">f</span> (<span class="italic">x</span> )) 的切线的斜率，而差商就是通过点 (<span class="italic">x</span> , <span class="italic">f</span> (<span class="italic">x</span> )) 和点 (<span class="italic">x</span> +<span class="italic">h</span> , <span class="italic">f</span> (<span class="italic">x</span> +<span class="italic">h</span> )) 的割 线的斜率。当 <span class="italic">h</span> 越来越小，割线与切线就越来越接近（见图 8-2）。</p><p class="calibre_">很多函数可以精确地计算导数，比如平方函数 <tt class="calibre7">square</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def square(x):<br class="calibre12"/>    return x * x<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">它的导数为：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def derivative(x):<br class="calibre12"/>    return 2 * x<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你可以通过计算来确认——如果你想的话——先显式地计算差商，再取极限。</p><p class="calibre_">如果算不出梯度（或不想算）呢？ Python 中无法直接运算极限，但可以通过计算一个很小的变动 <tt class="calibre7">e</tt> 的差商来估算微分。图 8-3 给出了这个估算的结果：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>derivative_estimate = partial(difference_quotient, square, h=0.00001)<br class="calibre12"/><br class="calibre12"/># 绘出导入matplotlib.pyplot作为plt的基本相同的形态<br class="calibre12"/>x = range(-10,10)<br class="calibre12"/>plt.title("精确的导数值与估计值")<br class="calibre12"/>plt.plot(x, map(derivative, x), 'rx', label='Actual')            # 用 x 表示<br class="calibre12"/>plt.plot(x, map(derivative_estimate, x), 'b+', label='Estimate') # 用 + 表示<br class="calibre12"/>plt.legend(loc=9)<br class="calibre12"/>plt.show()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_19"><img src="images/00024.jpg" class="calibre_75"/>
</p><p class="calibre_">
<span class="bold">图 8-3：差商近似值的拟合度</span>
</p><p class="calibre_">当 <tt class="calibre7">f</tt> 是一个多变量函数时，它有多个偏导数，每个偏导数表示仅有一个输入变量发生微小变化时函数 <tt class="calibre7">f</tt> 的变化。</p><p class="calibre_">我们把导数看成是其第 <span class="italic">i</span> 个变量的函数，其他变量保持不变，以此来计算它第 <span class="italic">i</span> 个偏导数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def partial_difference_quotient(f, v, i, h):<br class="calibre12"/>    """compute the ith partial difference quotient of f at v"""<br class="calibre12"/>    w = [v_j + (h if j == i else 0)    # 只对v的第i个元素增加h<br class="calibre12"/>         for j, v_j in enumerate(v)]<br class="calibre12"/><br class="calibre12"/>    return (f(w) - f(v)) / h<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">再以同样的方法估算它的梯度函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def estimate_gradient(f, v, h=0.00001):<br class="calibre12"/>    return [partial_difference_quotient(f, v, i, h)<br class="calibre12"/>            for i, _ in enumerate(v)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><blockquote class="calibre_33"><img src="images/00100.jpg" class="calibre_10"/> 　“差商估算法”的主要缺点是计算代价很大。如果 <tt class="calibre7">v</tt> 长度为 <span class="italic">n</span> ，那么 <tt class="calibre7">estimate_gradient</tt> 为了计算 <tt class="calibre7">f</tt> 需要 2<span class="italic">n</span> 个不同的输入变量。如果你需要反复计算梯度，那需要做很多额外的工作。</blockquote><div class="mbp_pagebreak" id="calibre_pb_57"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
