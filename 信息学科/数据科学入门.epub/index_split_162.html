<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos709380" class="calibre_15"><span class="calibre6"><span class="bold"> 23.4　</span></span><span class="calibre6"><tt class="calibre7"><span class="bold">SELECT</span></tt></span><span class="calibre6"><span class="bold">  </span></span></p><p class="calibre_">通常，我们不会直接查看 SQL 表，而是通过一个 <tt class="calibre7">SELECT</tt> 语句查询：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>SELECT * FROM users;                           -- 得到所有内容<br class="calibre12"/>SELECT * FROM users LIMIT 2;                   -- 得到前两行<br class="calibre12"/>SELECT user_id FROM users;                     -- 只得到特定列<br class="calibre12"/>SELECT user_id FROM users WHERE name = 'Dunn'; -- 只得到特定行<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你也可以使用 <tt class="calibre7">SELECT</tt> 语句计算字段：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>SELECT LENGTH(name) AS name_length FROM users;<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们会给 <tt class="calibre7">Table</tt> 类一个 <tt class="calibre7">select()</tt> 方法来返回一个新 <tt class="calibre7">Table</tt> 。这个方法采用两种可选语句。</p><div class="calibre_5"> </div><ul class="calibre_6"><li value="1" class="calibre_7"><p class="calibre_">
<tt class="calibre7">keep_columns</tt> 声明了你希望在结果中保留的列名。如果没提供这一项，结果会包含所有的列。</p></li><li value="2" class="calibre_8"><p class="calibre_">
<tt class="calibre7">additional_columns</tt> 是一个字典，它的键是新列名，值是指定如何计算新列值的函数。</p></li></ul><p class="calibre_">如果两种都不用，你只会得到一个表的机械复制的版本：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def select(self, keep_columns=None, additional_columns=None):<br class="calibre12"/><br class="calibre12"/>    if keep_columns is None:         # 如果没有指定列<br class="calibre12"/>        keep_columns = self.columns  # 则返回所有列<br class="calibre12"/><br class="calibre12"/>    if additional_columns is None:<br class="calibre12"/>        additional_columns = {}<br class="calibre12"/><br class="calibre12"/>    # 结果的新表<br class="calibre12"/>    result_table = Table(keep_columns + additional_columns.keys())<br class="calibre12"/><br class="calibre12"/>    for row in self.rows:<br class="calibre12"/>        new_row = [row[column] for column in keep_columns]<br class="calibre12"/>        for column_name, calculation in additional_columns.iteritems():<br class="calibre12"/>            new_row.append(calculation(row))<br class="calibre12"/>        result_table.insert(new_row)<br class="calibre12"/><br class="calibre12"/>    return result_table<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">
<tt class="calibre7">select()</tt> 会返回新的表，而一般的 SQL <tt class="calibre7">SELECT</tt> 仅会生成某种临时结果集（除非你显式地将结果导入一个表）。</p><p class="calibre_">我们也需要 <tt class="calibre7">where()</tt> 和 <tt class="calibre7">limit()</tt> 方法。两种方法都很简单：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def where(self, predicate=lambda row: True):<br class="calibre12"/>    """return only the rows that satisfy the supplied predicate"""<br class="calibre12"/>    where_table = Table(self.columns)<br class="calibre12"/>    where_table.rows = filter(predicate, self.rows)<br class="calibre12"/>    return where_table<br class="calibre12"/><br class="calibre12"/>def limit(self, num_rows):<br class="calibre12"/>    """return only the first num_rows rows"""<br class="calibre12"/>    limit_table = Table(self.columns)<br class="calibre12"/>    limit_table.rows = self.rows[:num_rows]<br class="calibre12"/>    return limit_table<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">然后我们可以轻松创建与先前的 SQL 语句等价的 NotQuiteABase 语句：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># SELECT * FROM users;<br class="calibre12"/>users.select()<br class="calibre12"/><br class="calibre12"/># SELECT * FROM users LIMIT 2;<br class="calibre12"/>users.limit(2)<br class="calibre12"/><br class="calibre12"/># SELECT user_id FROM users;<br class="calibre12"/>users.select(keep_columns=["user_id"])<br class="calibre12"/><br class="calibre12"/># SELECT user_id FROM users WHERE name = 'Dunn';<br class="calibre12"/>users.where(lambda row: row["name"] == "Dunn") \<br class="calibre12"/>     .select(keep_columns=["user_id"])<br class="calibre12"/><br class="calibre12"/># SELECT LENGTH(name) AS name_length FROM users;<br class="calibre12"/>def name_length(row): return len(row["name"])<br class="calibre12"/><br class="calibre12"/>users.select(keep_columns=[],<br class="calibre12"/>             additional_columns = { "name_length" : name_length })<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">注意——不同于本书其他部分——我在这里用反斜线 <tt class="calibre7">\</tt> 来表示程序语句的跨行延续。与其他方法相比，我认为这种方法可以让串连在一起的 NotQuiteABase 查询语句更易读。</p><div class="mbp_pagebreak" id="calibre_pb_162"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
