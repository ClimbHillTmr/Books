<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos469685" class="calibre_"><span class="calibre6"><span class="bold"> 15.6　题外话：Bootstrap </span></span></p><p class="calibre_">假设我们有一个含有 <span class="italic">n</span> 个数据点的样本，并且这些点是按照某种（我们不知道的）概率分布生成的：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>data = get_sample(num_points=n)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">在第 5 章中，我们曾经编写了一个计算观测数据中位数的函数，现在拿它来估算该分布本身的中位数。</p><p class="calibre_">但是，我们该如何了解这些估计值的可靠性呢？如果样品中所有的数据都非常接近 100，则实际的中位数很可能也非常接近 100。如果样本中一半左右的数据接近 0，而另一半则接近 200，那么我们就很难确信中位数到底接近多少。</p><p class="calibre_">如果我们能够不断获得新的样本，那么就可以计算出每个新样本的中位数，并观察这些中位数的分布情况。但是，一般这是不现实的。相反，我们可以利用 Bootstrap 来获得新的数据集，即选择 <span class="italic">n</span> 个数据点并用原来的数据将其<span class="bold">替换</span> ，然后计算合成的数据集的中位数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def bootstrap_sample(data):<br class="calibre12"/>    """randomly samples len(data) elements with replacement"""<br class="calibre12"/>    return [random.choice(data) for _ in data]<br class="calibre12"/><br class="calibre12"/>def bootstrap_statistic(data, stats_fn, num_samples):<br class="calibre12"/>    """evaluates stats_fn on num_samples bootstrap samples from data"""<br class="calibre12"/>    return [stats_fn(bootstrap_sample(data))<br class="calibre12"/>            for _ in range(num_samples)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">例如，考虑下列两个数据集：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 101个点都非常接近100<br class="calibre12"/>close_to_100 = [99.5 + random.random() for _ in range(101)]<br class="calibre12"/><br class="calibre12"/># 101个点钟，50个接近0，50个接近200<br class="calibre12"/>far_from_100 = ([99.5 + random.random()] +<br class="calibre12"/>                [random.random() for _ in range(50)] +<br class="calibre12"/>                [200 + random.random() for _ in range(50)])<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你计算每个数据集的中位数，会发现它们都非常接近 100。然而，如果你考察下面的语句：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>bootstrap_statistic(close_to_100, median, 100)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">大部分情况下你看到的数字确实非常接近 100。然而，如果你考察下面的语句：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>bootstrap_statistic(far_from_100, median, 100)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你会发现，不仅有许多数字接近 0，而且还有许多数字接近 200。</p><p class="calibre_">第一组中位数的 <tt class="calibre7">standard_deviation</tt> 接近 0，而第二组中位数的 <tt class="calibre7">standard_deviation</tt> 接近 100。（这种极端的情况通过人工检查数据很容易弄清楚，但一般情况下都不是真的。）</p><div class="mbp_pagebreak" id="calibre_pb_107"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
