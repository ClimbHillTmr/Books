<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos722432" class="calibre_"><span class="calibre6"><span class="bold"> 237　</span></span><span class="calibre6"><tt class="calibre7"><span class="bold">JOIN</span></tt></span><span class="calibre6"><span class="bold">  </span></span></p><p class="calibre_">关系型数据库的表通常是<span class="bold">正则化</span> 的，意味着依照冗余最小化的原则进行组织。例如，当我们处理用户对 Python 的兴趣时，我们只能为每个用户提供一个包含他的兴趣的列表。</p><p class="calibre_">SQL 表并不会包含真正的列表，它的实现机制是生成第二个表 <tt class="calibre7">user_interests</tt> ，这个表包含了从 <tt class="calibre7">user_id</tt> 到兴趣的一对多的关系。在 SQL 中，你可以这样做：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>CREATE TABLE user_interests (<br class="calibre12"/>    user_id INT NOT NULL,<br class="calibre12"/>    interest VARCHAR(100) NOT NULL<br class="calibre12"/>);<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">而在 NotQuiteABase 中，你需要建立表：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>user_interests = Table(["user_id", "interest"])<br class="calibre12"/>user_interests.insert([0, "SQL"])<br class="calibre12"/>user_interests.insert([0, "NoSQL"])<br class="calibre12"/>user_interests.insert([2, "SQL"])<br class="calibre12"/>user_interests.insert([2, "MySQL"])<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><blockquote class="calibre_33"><img src="images/00100.jpg" class="calibre_10"/> 　这样仍然有很多的冗余性——兴趣“SQL”存储在两个不同的地方。在实际数据库中，你需要将 <tt class="calibre7">user\_id</tt> 和 <tt class="calibre7">interest\_id</tt> 存在表 <tt class="calibre7">user\_interests</tt> 中，并建立将 <tt class="calibre7">interest\_id</tt> 映射到 <tt class="calibre7">interest</tt> 的第 3 个表 <tt class="calibre7">interests</tt> ，这样你就可以将每个兴趣名字仅仅存储一次。这里，我们会举比实际需要更复杂的例子。</blockquote><p class="calibre_">当我们的数据跨表存储时，该如果分析？当然是把表 <tt class="calibre7">JOIN</tt> 在一起。<tt class="calibre7">JOIN</tt> 可以将左表的行和右表对应的行结合在一起，其中，如何“对应”取决于我们对 join 的具体设定。</p><p class="calibre_">例如，为了找出对 SQL 感兴趣的用户，你需要：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>SELECT users.name<br class="calibre12"/>FROM users<br class="calibre12"/>JOIN user_interests<br class="calibre12"/>ON users.user_id = user_interests.user_id<br class="calibre12"/>WHERE user_interests.interest = 'SQL'<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">JOIN 意味着对 <tt class="calibre7">users</tt> 中的每行都要找到 <tt class="calibre7">user_id</tt> ，并找出 <tt class="calibre7">user_interests</tt> 中包含相同 <tt class="calibre7">user_id</tt> 的每一行，把它们联系起来。</p><p class="calibre_">注意，我们得指定哪个表需要参与 <tt class="calibre7">JOIN</tt> ，哪些列需要被 join <tt class="calibre7">ON</tt> 。这是一种 <tt class="calibre7">INNER JOIN</tt> ，返回的是条件匹配行（仅仅是行的组合）的组合。</p><p class="calibre_">
<tt class="calibre7">LEFT JOIN</tt> 不仅返回匹配行的组合，也返回左表中无匹配行的行（这种情形下，来自右表的字段值全部为 <tt class="calibre7">NULL</tt> ）。</p><p class="calibre_">通过 <tt class="calibre7">LEFT JOIN</tt> 可以很容易计算出每个用户的兴趣数目：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>SELECT users.id, COUNT(user_interests.interest) AS num_interests<br class="calibre12"/>FROM users<br class="calibre12"/>LEFT JOIN user_interests<br class="calibre12"/>ON users.user_id = user_interests.user_id<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">
<tt class="calibre7">LEFT JOIN</tt> 保证没任何兴趣的用户在并集结果数据集中仍有一席之地（来自表 <tt class="calibre7">user_interest</tt> 的字段值为 <tt class="calibre7">NULL</tt> ），并且 <tt class="calibre7">COUNT</tt> 只对非 <tt class="calibre7">NULL</tt> 值进行计数。</p><p class="calibre_">NotQuiteABase 的 <tt class="calibre7">join()</tt> 实现更为严格一些——它只对两表有共同列的部分做合并。虽然如此，也不妨把它写出来：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def join(self, other_table, left_join=False):<br class="calibre12"/><br class="calibre12"/>    join_on_columns = [c for c in self.columns            # 两个表的列<br class="calibre12"/>                       if c in other_table.columns]<br class="calibre12"/><br class="calibre12"/>    additional_columns = [c for c in other_table.columns  # 右表中的列<br class="calibre12"/>                          if c not in join_on_columns]<br class="calibre12"/><br class="calibre12"/>    # 左表中所有列 + 右表增加的列<br class="calibre12"/>    join_table = Table(self.columns + additional_columns)<br class="calibre12"/><br class="calibre12"/>    for row in self.rows:<br class="calibre12"/>        def is_join(other_row):<br class="calibre12"/>            return all(other_row[c] == row[c] for c in join_on_columns)<br class="calibre12"/><br class="calibre12"/>        other_rows = other_table.where(is_join).rows<br class="calibre12"/><br class="calibre12"/>        # 每对匹配的行生成一个新行<br class="calibre12"/>        for other_row in other_rows:<br class="calibre12"/>            join_table.insert([row[c] for c in self.columns] +<br class="calibre12"/>                              [other_row[c] for c in additional_columns])<br class="calibre12"/><br class="calibre12"/>        # 如果没有行匹配，在左并集的操作下生成空值<br class="calibre12"/>        if left_join and not other_rows:<br class="calibre12"/>            join_table.insert([row[c] for c in self.columns] +<br class="calibre12"/>                              [None for c in additional_columns])<br class="calibre12"/><br class="calibre12"/>    return join_table<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这样我们就找到了对 SQL 感兴趣的用户：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>sql_users = users \<br class="calibre12"/>    .join(user_interests) \<br class="calibre12"/>    .where(lambda row: row["interest"] == "SQL") \<br class="calibre12"/>    .select(keep_columns=["name"])<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">并且可以获得兴趣的数目：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def count_interests(rows):<br class="calibre12"/>    """counts how many rows have non-None interests"""<br class="calibre12"/>    return len([row for row in rows if row["interest"] is not None])<br class="calibre12"/><br class="calibre12"/>user_interest_counts = users \<br class="calibre12"/>    .join(user_interests, left_join=True) \<br class="calibre12"/>    .group_by(group_by_columns=["user_id"],<br class="calibre12"/>              aggregates={"num_interests" : count_interests })<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">在 SQL 中，还有一个 <tt class="calibre7">RIGHT JOIN</tt> ，它查询的是右表中没有匹配的行。还有 <tt class="calibre7">FULL OUTER JOIN</tt> ，它查询的是两表中无匹配的所有行。我们不再一一展示。</p><div class="mbp_pagebreak" id="calibre_pb_165"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
