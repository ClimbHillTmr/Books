<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos384940" class="calibre_"><span class="calibre6"><span class="bold"> 11.4　正确性 </span></span></p><p class="calibre_">当我不做数据科学的时候，我会涉猎医疗研究。在业余时间，我做了一个低成本、无害的新生儿测试——准确性高达 98%——测试新生儿是否会得白血病。我的律师确信我是有专利权的。所以我在这里把细节分享一下：仅仅当婴儿起名为 Luke 时预测会得白血病（因为这个名字听起来像白血病的英文 leukemia）。</p><p class="calibre_">如我们下面所见，这种测试确实有超过 98% 的准确性。然而，这是一个极为愚蠢的测试，也很好地解释了我们为什么不能仅用“准确率”这个概念来测量一个模型的好坏。</p><p class="calibre_">假设建立一个模型来做<span class="bold">二元</span> 的判断，比如：一封邮件是否是垃圾邮件？我们是否该聘用这位应聘者？这个乘客是潜藏的恐怖分子吗？</p><p class="calibre_">给定一个标签数据集和一个预测模型，每个数据集都会落在下面其中一个属性中。</p><div class="calibre_5"> </div><ul class="calibre_6"><li value="1" class="calibre_7"><p class="calibre_">真阳性：“这封邮件是垃圾邮件，我们做了正确的预测。”</p></li><li value="2" class="calibre_8"><p class="calibre_">假阳性（又称第 1 类错误）：“这封邮件不是垃圾邮件，但是我们预测它是垃圾邮件。”</p></li><li value="3" class="calibre_8"><p class="calibre_">假阴性（又称第 2 类错误）：“这封邮件是垃圾邮件，但是我们预测它不是垃圾邮件。”</p></li><li value="4" class="calibre_8"><p class="calibre_">真阴性：“这封邮件不是垃圾邮件，而且我们正确地预测了它不是垃圾邮件。”</p></li></ul><p class="calibre_">我们常用<span class="bold">混淆矩阵</span> （confusion matrix）中的计数来表示上面的四种情况：</p><p class="calibre13"> </p><table border="1" valign="top" class="calibre_37"><tr valign="top" class="calibre14"><th valign="top" class="calibre15"><span class="calibre11"><span class="bold">  </span></span><p class="calibre_38"><span class="calibre11"><span class="bold">  </span></span></p></th><th valign="top" class="calibre15"><span class="calibre11"><span class="bold">  </span></span><p class="calibre_38"><span class="calibre11"><span class="bold">垃圾邮件 </span></span></p></th><th valign="top" class="calibre15"><span class="calibre11"><span class="bold">  </span></span><p class="calibre_38"><span class="calibre11"><span class="bold">非垃圾邮件 </span></span></p></th></tr><tr valign="top" class="calibre14"><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">预测“是垃圾邮件” </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">真阳性 </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">假阳性 </span></p></td></tr><tr valign="top" class="calibre_40"><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">预测“非垃圾邮件” </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">假阴性 </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">真阴性 </span></p></td></tr></table><p class="calibre_">让我们来看看我的白血病测试是如何符合这种框架的。现如今，大约每 1000 名婴儿中有 5 人会起名叫 Luke（<a href="http://www.babycenter.com/babyNameAllPops.htm?babyNameId=2918" class="calibre3">http://www.babycenter.com/babyNameAllPops.htm?babyNameId=2918</a> ）。每人一生中罹患白血病的概率大约是 1.4%，或者说每 1000 人中会有 14 人患病（<a href="http://seer.cancer.gov/statfacts/html/leuks.html" class="calibre3">http://seer.cancer.gov/statfacts/html/leuks.html</a> ）。</p><p class="calibre_">如果我们相信这两个因素是独立的，然后对 1 百万人运用我的“Luke 是白血病患者”测试，预计能看到这样的混淆矩阵：</p><p class="calibre13"> </p><table border="1" valign="top" class="calibre_37"><tr valign="top" class="calibre14"><th valign="top" class="calibre15"><span class="calibre11"><span class="bold">  </span></span><p class="calibre_38"><span class="calibre11"><span class="bold">  </span></span></p></th><th valign="top" class="calibre15"><span class="calibre11"><span class="bold">  </span></span><p class="calibre_38"><span class="calibre11"><span class="bold">白血病 </span></span></p></th><th valign="top" class="calibre15"><span class="calibre11"><span class="bold">  </span></span><p class="calibre_38"><span class="calibre11"><span class="bold">非白血病 </span></span></p></th><th valign="top" class="calibre15"><span class="calibre11"><span class="bold">  </span></span><p class="calibre_38"><span class="calibre11"><span class="bold">总计 </span></span></p></th></tr><tr valign="top" class="calibre14"><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">Luke </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">70 </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">4930 </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">5000 </span></p></td></tr><tr valign="top" class="calibre_40"><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">非Luke </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">13 930 </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">981 070 </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">995 000 </span></p></td></tr><tr valign="top" class="calibre14"><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">总计 </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">14 000 </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">986 000 </span></p></td><td class="calibre16"><span class="calibre11">  </span><p class="calibre_39"><span class="calibre11">1 000 000 </span></p></td></tr></table><p class="calibre_">然后我们由此计算关于模型表现的多个统计量。例如，<span class="bold">准确率</span> （accuracy）定义为正确预测的比例：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def accuracy(tp, fp, fn, tn):<br class="calibre12"/>    correct = tp + tn<br class="calibre12"/>    total = tp + fp + fn + tn<br class="calibre12"/>    return correct / total<br class="calibre12"/><br class="calibre12"/>print accuracy(70, 4930, 13930, 981070)    # 0.98114<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">看起来这个数字令人印象十分深刻，但很明显这并不是一个好的测试，这意味着我们不能对原始的准确率有过多的信心。</p><p class="calibre_">更常见的做法是把<span class="bold">查准率</span> （precision）和<span class="bold">查全率</span> （recall）结合起来看待。查准率度量我的模型所做的关于“阳性”的预测有多准确：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def precision(tp, fp, fn, tn):<br class="calibre12"/>    return tp / (tp + fp)<br class="calibre12"/><br class="calibre12"/>print precision(70, 4930, 13930, 981070)    # 0.014<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">查全率度量我的模型所识别的“阳性”的比例：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def recall(tp, fp, fn, tn):<br class="calibre12"/>    return tp / (tp + fn)<br class="calibre12"/><br class="calibre12"/>print recall(70, 4930, 13930, 981070)      # 0.005<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这两个结果都低得可怕，反映出这是一个很不好的模型。</p><p class="calibre_">有时候可以把查准率和查全率组合成 F1 <span class="bold">得分</span> （F1 score），它是这样定义的：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def f1_score(tp, fp, fn, tn):<br class="calibre12"/>    p = precision(tp, fp, fn, tn)<br class="calibre12"/>    r = recall(tp, fp, fn, tn)<br class="calibre12"/><br class="calibre12"/>    return 2 * p * r / (p + r)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">它是查准率和查全率的调和平均值（<a href="https://en.wikipedia.org/wiki/Harmonic_mean" class="calibre3">https://en.wikipedia.org/wiki/Harmonic_mean</a> ），因此必然会落在两者之间。</p><p class="calibre_">模型的选择通常是查准率和查全率之间的权衡。一个模型如果在信心不足的情况下预测“是”，那么它的查全率可能会较高，但查准率却较低；而如果一个模型在信心十足的情况下预测“是”，那么它的查全率可能会较低，但查准率却较高。</p><p class="calibre_">另一方面，也可以把这当作假阳性和假阴性之间的权衡。预测的“是”太多通常会给出很多的假阳性。预测的“否”太多通常会给出很多的假阴性。</p><p class="calibre_">假设对白血病来说有 10 个风险因素，你的身体具备的因素越多，就越容易患上白血病。这种情况下，你可以假设进行一系列连续性的测试：“至少有一个风险因素预测会得白血病”“至少有两个风险因素预测会得白血病”诸如此类。随着临界值的不断提高，测试的查准率也提高了（因为具有更多风险因素的人更容易患上白血病），并且降低了测试的查全率（因为能够达到临界值的最终患病者越来越少）。对于类似这样的情况，选择合适的临界值实际上就是做出正确的权衡。</p><div class="mbp_pagebreak" id="calibre_pb_81"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
