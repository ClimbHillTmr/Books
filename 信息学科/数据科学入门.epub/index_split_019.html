<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos109399" class="calibre_15"><span class="calibre6"><span class="bold"> 2.2　进阶内容 </span></span></p><p class="calibre_">现在我们来看一些比较高级的 Python 特性，这些特性对开展数据工作特别有用。</p><p id="filepos109616" class="calibre_"><span class="calibre6"><span class="bold"> 2.2.1　排序 </span></span></p><p class="calibre_">每个 Python 列表都有一个 <tt class="calibre7">sort</tt> 方法可以恰当地排序。如果你不想弄乱你的列表，可以使用 <tt class="calibre7">sorted</tt> 函数，它会返回一个新列表：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>x = [4,1,2,3]<br class="calibre12"/>y = sorted(x)       # 结果是[1,2,3,4]，但x没有变<br class="calibre12"/>x.sort()            # x变为[1,2,3,4]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">默认情况下，<tt class="calibre7">sort</tt> （和 <tt class="calibre7">sorted</tt> ）基于元素之间的朴素比较从最小值到最大值对列表进行排序。</p><p class="calibre_">如果你想把元素按从最大值到最小值进行排序，可以指定参数 <tt class="calibre7">reverse=True</tt> 。除了比较元素本身，你还可以通过指定键来对函数的结果进行比较：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 通过绝对值对列表元素从最大到最小排序<br class="calibre12"/>x = sorted([-4,1,-2,3], key=abs, reverse=True) # 是[-4,3,-2,1]<br class="calibre12"/><br class="calibre12"/># 从最高数到最低数排序单词和计数<br class="calibre12"/>wc = sorted(word_counts.items(),<br class="calibre12"/>            key=lambda (word, count): count,<br class="calibre12"/>            reverse=True)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos111066" class="calibre_15"><span class="calibre6"><span class="bold"> 2.2.2　列表解析 </span></span></p><p class="calibre_">我们有时可能会想把一个列表转换为另一个列表，例如只保留其中一些元素，或更改其中一些元素，或者同时做这两种变动。可以执行这种操作的 Python 技巧叫作<span class="bold">列表解析</span> （list comprehension）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>even_numbers = [x for x in range(5) if x % 2 == 0]     # [0, 2, 4]<br class="calibre12"/>squares      = [x * x for x in range(5)]               # [0, 1, 4, 9, 16]<br class="calibre12"/>even_squares = [x * x for x in even_numbers]           # [0, 4, 16]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">类似地，你也可以把列表转换为字典或集合：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>square_dict = { x : x * x for x in range(5) }    # { 0:0, 1:1, 2:4, 3:9, 4:16}<br class="calibre12"/>square_set  = { x * x for x in [1, -1] }         # { 1 }<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你不需要来自原列表中的值，常规的方式是使用下划线作为变量：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>zeroes = [0 for _ in even_numbers]    # 和even_numbers有相同的长度<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">列表解析可以包括多个 <tt class="calibre7">for</tt> 语句：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>pairs = [(x, y)<br class="calibre12"/>         for x in range(10)<br class="calibre12"/>         for y in range(10)]    # 100个对(0,0) (0,1) ... (9,8), (9,9)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">其中后面的 <tt class="calibre7">for</tt> 语句可以使用前面的 <tt class="calibre7">for</tt> 语句的结果：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>increasing_pairs = [(x, y)                       # 只考虑x &lt; y的对<br class="calibre12"/>                    for x in range(10)           # range(lo, hi) 与之相等<br class="calibre12"/>                    for y in range(x + 1, 10)]   # [lo, lo + 1, ..., hi - 1]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们会经常用到列表解析。</p><p id="filepos113647" class="calibre_"><span class="calibre6"><span class="bold"> 2.2.3　生成器和迭代器 </span></span></p><p class="calibre_">列表的一个问题是它很容易变得非常大。<tt class="calibre7">range(1000000)</tt> 能创建一个有 100 万个元素的列表：如果你需要每次只处理其中一个元素，这将会是极大的资源浪费（或会导致内存不足）；如果你只需要前面的几个值，那对整个列表都进行计算也是一种浪费。</p><p class="calibre_">
<span class="bold">生成器</span> （generator）是一种可以对其进行迭代（对我们来说，通常使用 <tt class="calibre7">for</tt> 语句）的程序，但是它的值只按需延迟（lazily）产生。</p><p class="calibre_">创建生成器的一种方法是使用函数和 <tt class="calibre7">yield</tt> 运算符：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def lazy_range(n):<br class="calibre12"/>    """a lazy version of range"""<br class="calibre12"/>    i = 0<br class="calibre12"/>    while i &lt; n:<br class="calibre12"/>        yield i<br class="calibre12"/>        i += 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">下面的循环会每次消耗一个 <tt class="calibre7">yield</tt> 值直到一个也不剩：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>for i in lazy_range(10):<br class="calibre12"/>    do_something_with(i)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">（Python 确实有一个和 <tt class="calibre7">lazy_range</tt> 一样的函数，叫作 <tt class="calibre7">xrange</tt> ，并且在 Python 3 中，<tt class="calibre7">range</tt> 函数本身就是延迟的。）这意味着，你甚至可以创建一个无限的序列：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def natural_numbers():<br class="calibre12"/>    """returns 1, 2, 3, ..."""<br class="calibre12"/>    n = 1<br class="calibre12"/>    while True:<br class="calibre12"/>        yield n<br class="calibre12"/>        n += 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">尽管在没有使用某种 <tt class="calibre7">break</tt> 逻辑语句时，你不应该做这种迭代的。</p><blockquote class="calibre_14"><img src="images/00095.jpg" class="calibre_9"/> 　延迟的缺点是，你只能通过生成器迭代一次。如果需要多次迭代某个对象，你就需要每次都重新创建一个生成器，或者使用列表。</blockquote><p class="calibre_">第二种创建生成器的方法是使用包含在圆括号中的 <tt class="calibre7">for</tt> 语句解析：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>lazy_evens_below_20 = (i for i in lazy_range(20) if i % 2 == 0)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">前面提过，每个 <tt class="calibre7">dict</tt> 都有一个 <tt class="calibre7">items()</tt> 方法可以返回它的键值对的列表。更常见的做法是使用 <tt class="calibre7">iteritems()</tt> 方法：当我们在列表上迭代的时候它延迟 <tt class="calibre7">yield</tt> 为每次一个键值对。</p><p id="filepos116661" class="calibre_"><span class="calibre6"><span class="bold"> 2.2.4　随机性 </span></span></p><p class="calibre_">当我们学习数据科学时，会经常需要生成随机数。可以使用 <tt class="calibre7">random</tt> 模块生成随机数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import random<br class="calibre12"/><br class="calibre12"/>four_uniform_randoms = [random.random() for _ in range(4)]<br class="calibre12"/><br class="calibre12"/># [0.8444218515250481,<br class="calibre12"/>#  0.7579544029403025,<br class="calibre12"/>#  0.420571580830845,<br class="calibre12"/>#  0.25891675029296335]<br class="calibre12"/># random.random()生成在0-1之间均匀分布的随机数，是最常用的随机函数<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">
<tt class="calibre7">random</tt> 模块实际上生成的是基于一种内部状态的确定性的伪随机数。如果你想得到可复生的结果，可以用 <tt class="calibre7">random.seed</tt> 生成随机数种子：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>random.seed(10)          # 设置随机数种子为10<br class="calibre12"/>print random.random()    # 0.57140259469<br class="calibre12"/>random.seed(10)          # 重设随机数种子为10<br class="calibre12"/>print random.random()    # 再次得到0.57140259469<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">有时候我们用 <tt class="calibre7">random.randrange</tt> 生成随机数，它会取 1 到 2 个参数，并从对应的 <tt class="calibre7">range()</tt> 函数随机选择一个元素返回：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>random.randrange(10)    # 从range(10) = [0, 1, ..., 9]中随机选取<br class="calibre12"/>random.randrange(3, 6)  # 从range(3, 6) = [3, 4, 5]中随机选取<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">还有其他一些比较方便的方法，如 <tt class="calibre7">Random.shuffle</tt> 可随机地重排列表中的元素：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>up_to_ten = range(10)<br class="calibre12"/>random.shuffle(up_to_ten)<br class="calibre12"/>print up_to_ten<br class="calibre12"/># [2, 5, 1, 9, 7, 3, 8, 6, 4, 0]，（你的结果可能不同）<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你需要从列表中随机取一个元素，可以使用 <tt class="calibre7">random.choice</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>my_best_friend = random.choice(["Alice", "Bob", "Charlie"])    # 对我来说是"Bob"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你需要不替换地（即不重复地）随机选择一个元素的样本，可以使用 <tt class="calibre7">random.sample</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>lottery_numbers = range(60)<br class="calibre12"/>winning_numbers = random.sample(lottery_numbers, 6)  # [16, 36, 10, 6, 25, 9]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">选择一个<span class="bold">允许替换</span> 的（即允许重复的）元素样本，只需多次调用 <tt class="calibre7">random.choice</tt> 即可：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>four_with_replacement = [random.choice(range(10))<br class="calibre12"/>                         for _ in range(4)]<br class="calibre12"/># [9, 4, 4, 2]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos120073" class="calibre_15"><span class="calibre6"><span class="bold"> 2.2.5　正则表达式 </span></span></p><p class="calibre_">正则表达式提供了一种搜索文本的方法。它超乎想象地有用，但同时也相当复杂，以至于需要专门的书籍来讲解。之后的内容会频繁涉及正则表达式，届时我们再详述，这里只给出 Python 中如何使用正则表达式的例子：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import re<br class="calibre12"/><br class="calibre12"/>print all([                                 # 所有这些语句都为true，因为<br class="calibre12"/>    not re.match("a", "cat"),               # * 'cat'不以'a'开头<br class="calibre12"/>    re.search("a", "cat"),                  # * 'cat'里有一个字符'a'<br class="calibre12"/>    not re.search("c", "dog"),              # * 'dog'里没有字符'c'<br class="calibre12"/>    3 == len(re.split("[ab]", "carbs")),    # * 分割掉a,b，剩余长度为3<br class="calibre12"/>    "R-D-" == re.sub("[0-9]", "-", "R2D2")  # 用虚线进行位的替换<br class="calibre12"/>    ] # 打印True<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos121287" class="calibre_15"><span class="calibre6"><span class="bold"> 2.2.6　面向对象的编程 </span></span></p><p class="calibre_">就像许多语言一样，Python 允许你定义<span class="bold">类</span> （class）。类可以封装对象和函数来对它们进行操作。有时候我们会用类来使代码更加干净整洁。解释类的用法的最简单方式可能是构建一个有超多注释的例子。</p><p class="calibre_">假设没有内置的 Python 集合，那我们可能会想到去创建自己的 <tt class="calibre7">Set</tt> 类。</p><p class="calibre_">我们创建的类会有什么样的行为呢？给定一个 <tt class="calibre7">Set</tt> ，我们需要能在其中加入（<tt class="calibre7">add</tt> ）项目，移除（<tt class="calibre7">remove</tt> ）项目，以及检查其中是否包含（<tt class="calibre7">contains</tt> ）某个值。我们把这些功能创建为<span class="bold">成员</span> （member）函数，意思是我们可以通过在 <tt class="calibre7">Set</tt> 对象后面加点（<tt class="calibre7">.</tt> ）来访问它们：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 按惯例，我们给下面的类起个PascalCase的名字<br class="calibre12"/>class Set:<br class="calibre12"/><br class="calibre12"/>    # 这些是成员函数<br class="calibre12"/>    # 每个函数都取第一个参数"self"（另一种惯例）<br class="calibre12"/>    # 它表示所用到的特别的集合对象<br class="calibre12"/><br class="calibre12"/>    def __init__(self, values=None):<br class="calibre12"/>        """This is the constructor.<br class="calibre12"/>        It gets called when you create a new Set.<br class="calibre12"/>        You would use it like<br class="calibre12"/>        s1 = Set()           # 空集合<br class="calibre12"/>        s2 = Set([1,2,2,3])  # 用值初始化"""<br class="calibre12"/><br class="calibre12"/>        self.dict = {} # Set的每一个实例都有自己的dict属性<br class="calibre12"/>                       # 我们会用这个属性来追踪成员关系<br class="calibre12"/>        if values is not None:<br class="calibre12"/>            for value in values:<br class="calibre12"/>                self.add(value)<br class="calibre12"/><br class="calibre12"/>    def __repr__(self):<br class="calibre12"/>        """this is the string representation of a Set object<br class="calibre12"/>        if you type it at the Python prompt or pass it to str()"""<br class="calibre12"/>        return "Set: " + str(self.dict.keys())<br class="calibre12"/><br class="calibre12"/>    # 通过成为self.dict中对应值为True的键，来表示成员关系<br class="calibre12"/>    def add(self, value):<br class="calibre12"/>        self.dict[value] = True<br class="calibre12"/><br class="calibre12"/>    # 如果它在字典中是一个键，那么在集合中就是一个值<br class="calibre12"/>    def contains(self, value):<br class="calibre12"/>        return value in self.dict<br class="calibre12"/><br class="calibre12"/>    def remove(self, value):<br class="calibre12"/>        del self.dict[value]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">可以像下面这样来用上面的函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>s = Set([1,2,3])<br class="calibre12"/>s.add(4)<br class="calibre12"/>print s.contains(4)       # True<br class="calibre12"/>s.remove(3)<br class="calibre12"/>print s.contains(3)       # False<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos124529" class="calibre_15"><span class="calibre6"><span class="bold"> 2.2.7　函数式工具 </span></span></p><p class="calibre_">在传递函数的时候，有时我们可能想部分地应用（或 curry）函数来创建新函数。下面是一个简单的例子，假设我们有一个含两个变量的函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def exp(base, power):<br class="calibre12"/>    return base ** power<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们想用它来创建一个单变量的函数 <tt class="calibre7">two_to_the</tt> 。它的输入是一个幂次（<tt class="calibre7">power</tt> ），输出的是 <tt class="calibre7">exp(2, power)</tt> 的结果。</p><p class="calibre_">当然，我们可以用 <tt class="calibre7">def</tt> 来实现，但它有时候使用起来并不太方便：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def two_to_the(power):<br class="calibre12"/>    return exp(2, power)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">一个另辟蹊径的方法是使用 <tt class="calibre7">functools.partial</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>from functools import partial<br class="calibre12"/>two_to_the = partial(exp, 2)      # 现在是一个包含一个变量的函数<br class="calibre12"/>print two_to_the(3)               # 8<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你为后面的参数指定了名字，也能用 <tt class="calibre7">partial</tt> 来填充这些参数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>square_of = partial(exp, power=2)<br class="calibre12"/>print square_of(3)                  # 9<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你 curry 中间函数的参数，就会变得混乱起来，所以要努力避免这么做。</p><p class="calibre_">偶尔我们也会使用函数 <tt class="calibre7">map</tt> 、<tt class="calibre7">reduce</tt> 和 <tt class="calibre7">filter</tt> ，它们为列表解析提供了函数式替换方案：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def double(x):<br class="calibre12"/>    return 2 * x<br class="calibre12"/><br class="calibre12"/>xs = [1, 2, 3, 4]<br class="calibre12"/>twice_xs = [double(x) for x in xs]         # [2, 4, 6, 8]<br class="calibre12"/>twice_xs = map(double, xs)                 # 和上面一样<br class="calibre12"/>list_doubler = partial(map, double)        # double了一个列表的*function*<br class="calibre12"/>twice_xs = list_doubler(xs)                # 同样是[2, 4, 6, 8]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果你提供了多个列表，可以对带有多个参数的函数使用 <tt class="calibre7">map</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def multiply(x, y): return x * y<br class="calibre12"/><br class="calibre12"/>products = map(multiply, [1, 2], [4, 5]) # [1 * 4, 2 * 5] = [4, 10]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">类似地，<tt class="calibre7">filter</tt> 做了列表解析中 <tt class="calibre7">if</tt> 的工作：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def is_even(x):<br class="calibre12"/>    """True if x is even, False if x is odd"""<br class="calibre12"/>    return x % 2 == 0<br class="calibre12"/><br class="calibre12"/>x_evens = [x for x in xs if is_even(x)]       # [2, 4]<br class="calibre12"/>x_evens = filter(is_even, xs)                 # 和上面一样<br class="calibre12"/>list_evener = partial(filter, is_even)        # filter了一个列表的*function*<br class="calibre12"/>x_evens = list_evener(xs)                     # 同样是[2, 4]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">
<tt class="calibre7">reduce</tt> 结合了列表的头两个元素，它们的结果又结合了列表的第 3 个元素，这个结果之后又结合了第 4 个元素，依次下去，直到得到一个单独的结果：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>x_product = reduce(multiply, xs)              # = 1 * 2 * 3 * 4 = 24<br class="calibre12"/>list_product = partial(reduce, multiply)      # reduce了一个列表的*function*<br class="calibre12"/>x_product = list_product(xs)                  # 同样是24<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos128979" class="calibre_15"><span class="calibre6"><span class="bold"> 2.2.8　枚举 </span></span></p><p class="calibre_">有时候，你可能想在一个列表上迭代，并且同时使用它的元素和元素的索引：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 非Python用法<br class="calibre12"/>for i in range(len(documents)):<br class="calibre12"/>    document = documents[i]<br class="calibre12"/>    do_something(i, document)<br class="calibre12"/><br class="calibre12"/># 也非Python用法<br class="calibre12"/>i = 0<br class="calibre12"/>for document in documents:<br class="calibre12"/>    do_something(i, document)<br class="calibre12"/>    i += 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">Python 惯用的解决方案是使用枚举（<tt class="calibre7">enumerate</tt> ），它会产生 <tt class="calibre7">(index, element)</tt> 元组：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>for i, document in enumerate(documents):<br class="calibre12"/>    do_something(i, document)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">类似地，如果你只想要索引，则执行：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>for i in range(len(documents)): do_something(i)     # 非Python用法<br class="calibre12"/>for i, _ in enumerate(documents): do_something(i)   # Python用法<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们会频繁用到枚举。</p><p id="filepos130421" class="calibre_"><span class="calibre6"><span class="bold"> 2.2.9　压缩和参数拆分 </span></span></p><p class="calibre_">如果想把两个或多个列表压缩在一起，可以使用 <tt class="calibre7">zip</tt> 把多个列表转换为一个对应元素的元 组的单个列表中：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>list1 = ['a', 'b', 'c']<br class="calibre12"/>list2 = [1, 2, 3]<br class="calibre12"/>zip(list1, list2)         # 是[('a', 1), ('b', 2), ('c', 3)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果列表的长度各异，<tt class="calibre7">zip</tt> 会在第一个列表结束时停止。</p><p class="calibre_">可以使用一种特殊的方法“解压”一个列表：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>pairs = [('a', 1), ('b', 2), ('c', 3)]<br class="calibre12"/>letters, numbers = zip(*pairs)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">其中的星号执行<span class="bold">参数拆分</span> （argument unpacking）。参数拆分使用 <tt class="calibre7">pairs</tt> 的元素作为独立的参数传给 <tt class="calibre7">zip</tt> 。这就和调用以下函数的结果是一样的：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>zip(('a', 1), ('b', 2), ('c', 3))<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">它返回 <tt class="calibre7">[('a','b','c')</tt> ，<tt class="calibre7">('1','2','3')]</tt> 。</p><p class="calibre_">你可以在任何函数上使用参数拆分：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def add(a, b): return a + b<br class="calibre12"/><br class="calibre12"/>add(1, 2)     # 返回3<br class="calibre12"/>add([1, 2])   # TypeError!<br class="calibre12"/>add(*[1, 2])  # 返回3<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">参数拆分并不是特别有用，但当我们用到它的时候，会觉得这是个不错的技巧。</p><p id="filepos132381" class="calibre_"><span class="calibre6"><span class="bold"> 2.2.10　</span></span><span class="calibre6"><tt class="calibre7"><span class="bold">args</span></tt></span><span class="calibre6"><span class="bold"> 和</span></span><span class="calibre6"><tt class="calibre7"><span class="bold">kwargs</span></tt></span><span class="calibre6"><span class="bold">  </span></span></p><p class="calibre_">假如我们想创建一个更高阶的函数，把某个函数 <tt class="calibre7">f</tt> 作为输入，并返回一个对任意输入都返回 <tt class="calibre7">f</tt> 值两倍的新函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def doubler(f):<br class="calibre12"/>    def g(x):<br class="calibre12"/>        return 2 * f(x)<br class="calibre12"/>    return g<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这个函数在有些情况下可以实现：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def f1(x):<br class="calibre12"/>    return x + 1<br class="calibre12"/><br class="calibre12"/>g = doubler(f1)<br class="calibre12"/>print g(3)           # 8 (== ( 3 + 1) * 2)<br class="calibre12"/>print g(-1)          # 0 (== (-1 + 1) * 2)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">但对于有多个参数的函数来说，就不适用：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def f2(x, y):<br class="calibre12"/>    return x + y<br class="calibre12"/><br class="calibre12"/>g = doubler(f2)<br class="calibre12"/>print g(1, 2)    # TypeError: g()只能有一个参数（给定了两个）<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们所需要的是一种指定一个可以取任意参数的函数的方法，利用参数拆分和一点点魔法就可以做到这一点：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def magic(*args, **kwargs):<br class="calibre12"/>    print "unnamed args:", args<br class="calibre12"/>    print "keyword args:", kwargs<br class="calibre12"/><br class="calibre12"/>magic(1, 2, key="word", key2="word2")<br class="calibre12"/><br class="calibre12"/># 输出<br class="calibre12"/># 未命名args: (1, 2)<br class="calibre12"/># 关键词args: {'key2': 'word2', 'key': 'word'}<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">也就是说，当我们定义了这样一个函数时，<tt class="calibre7">args</tt> 是一个它的未命名参数的元组，而 <tt class="calibre7">kwargs</tt> 是一个它的已命名参数的 <tt class="calibre7">dict</tt> 。反过来也适用，你可以使用一个 <tt class="calibre7">list</tt> （或者 <tt class="calibre7">tuple</tt> ）和 <tt class="calibre7">dict</tt> 来给函数<span class="bold">提供</span> 参数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def other_way_magic(x, y, z):<br class="calibre12"/>    return x + y + z<br class="calibre12"/><br class="calibre12"/>x_y_list = [1, 2]<br class="calibre12"/>z_dict = { "z" : 3 }<br class="calibre12"/>print other_way_magic(*x_y_list, **z_dict)    # 6<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">参照以上例子，你可以充分利用这种技巧，随意发挥。我们将会只用它来创建可以将任意参数作为输入的高阶函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def doubler_correct(f):<br class="calibre12"/>    """works no matter what kind of inputs f expects"""<br class="calibre12"/>    def g(*args, **kwargs):<br class="calibre12"/>        """whatever arguments g is supplied, pass them through to f"""<br class="calibre12"/>        return 2 * f(*args, **kwargs)<br class="calibre12"/>    return g<br class="calibre12"/><br class="calibre12"/>g = doubler_correct(f2)<br class="calibre12"/>print g(1, 2) # 6<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos135851" class="calibre_15"><span class="calibre6"><span class="bold"> 2.2.11　欢迎来到DataSciencester </span></span></p><p class="calibre_">新员工的入职培训到此结束。哦，当然，不要浪费任何所学的东西。</p><div class="mbp_pagebreak" id="calibre_pb_19"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
