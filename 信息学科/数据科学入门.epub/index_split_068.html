<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos321907" class="calibre_"><span class="calibre6"><span class="bold"> 9.5　案例：使用Twitter API </span></span></p><p class="calibre_">Twitter 是一个非常好的数据源。你可以从它得到实时的新闻，可以用它来度量对当前事件的反应，可以利用它找到与特定主题有关的链接。使用 Twitter 可以做几乎任何你能想到的事，只要你能获得它的数据。可以通过它的 API 来获得数据。</p><p class="calibre_">为了和 Twitter API 互动，我们需要使用 Twython 库（<tt class="calibre7">pip install twython</tt> ，<a href="https://github.com/ryanmcgrath/twython" class="calibre3">https://github.com/ryanmcgrath/twython</a> ）。实际上有很多 Python Twitter 的库，但这一个是我用过的库中最好用的一个。你也可以尝试一下其他的库。</p><p id="filepos322709" class="calibre_"><span class="calibre6"><span class="bold"> 获取证明文件 </span></span></p><p class="calibre_">为了使用 Twitter 的 API，需要先获取一些证明文件（为此你无论如何都要有一个 Twitter 的账户，这样你就能成为一个活跃友好的 Twitter <tt class="calibre7">#datascience</tt> 社区的一部分）。就像那些所有我不能控制的网站的指令一样，它们会在某个时刻过时，但是现在还是能发挥一段时间的作用的。（尽管在我写作本书的这段时间里，它们至少已经变更过一次了，所以祝你好运！）</p><p class="calibre_">1. 找到链接 <a href="https://apps.twitter.com/" class="calibre3">https://apps.twitter.com/</a> 。</p><p class="calibre_">2. 如果你还没有注册，点击“注册”，并输入你的 Twitter 用户名和密码。</p><p class="calibre_">3. 点击“创建新 App”。</p><p class="calibre_">4. 给它起个名字（比如“数据科学”）并添加一些描述，放上一个任意的 URL 作为网址（不用在乎是哪个）。</p><p class="calibre_">5. 同意“服务条款”并点击“创建”。</p><p class="calibre_">6. 注意消费者钥匙（consumer key）和消费者密码（consumer secret）。</p><p class="calibre_">7. 点击“创建我的访问令牌”（access token）。</p><p class="calibre_">8. 注意访问令牌和访问令牌密码（你可能需要刷新页面）。</p><p class="calibre_">消费者钥匙和消费者密码告诉 Twitter 什么应用正在访问它的 API，而访问令牌和访问令牌密码告诉 Twitter 是<span class="bold">谁</span> 正在访问它的 API。如果你曾经用 Twitter 账户访问过一些其他网站，“点击验证”页面会生成一个访问令牌，网站会用这个令牌来告诉 Twitter 访问者是你（或者至少是来自你的操作）。因为不需要这种“让任何人登录”的功能，我们可以获得静态生成的访问令牌和访问令牌密码。</p><blockquote class="calibre_14"><img src="images/00110.jpg" class="calibre_11"/> 　消费者钥匙 / 密码和访问令牌钥匙 / 密码应该被看成是密码（password）。你不该分享它们，不该把它们印在书里，也不应该把它们记录在 GitHub 公共代码库里。一种简单的方法是把它们存储在不会被签入的 credentials.json 文件里，而且可以使用 <tt class="calibre7">json.loads</tt> 取回它们。</blockquote><p class="calibre_">
<span class="bold">使用Twython</span>
</p><p class="calibre_">首先我们来看看 Search API（<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets" class="calibre3">https://dev.twitter.com/docs/api/1.1/get/search/tweets</a> ），这个操作只需要消费者钥匙和密码，无需访问令牌或密码：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>from twython import Twython<br class="calibre12"/><br class="calibre12"/>twitter = Twython(CONSUMER_KEY, CONSUMER_SECRET)<br class="calibre12"/><br class="calibre12"/># 搜索包含短语“数据科学”的推文<br class="calibre12"/>for status in twitter.search(q='"data science"')["statuses"]:<br class="calibre12"/>    user = status["user"]["screen_name"].encode('utf-8')<br class="calibre12"/>    text = status["text"].encode('utf-8')<br class="calibre12"/>    print user, ":", text<br class="calibre12"/>    print<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><blockquote class="calibre_68"><img src="images/00100.jpg" class="calibre_10"/>
</blockquote><blockquote class="calibre_14">因为推文中经常包含 <tt class="calibre7">print</tt> 函数无法处理的 Unicode 字符，所以有必要使用 <tt class="calibre7">.encode("utf-8")</tt> 来应对这个问题。（如果对这个问题放任不管，很有可能会得到 <tt class="calibre7">UnicodeEncodeError</tt> 的报错。）</blockquote><blockquote class="calibre_14">几乎可以肯定，你会在数据科学家职业生涯的某些时刻遇到严重的 Unicode 问题，这时你需要参考 Python 文档（<a href="https://docs.python.org/2/howto/unicode.html" class="calibre3">https://docs.python.org/2/howto/unicode.html</a> ）或者勉为其难地开始使用 Python 3 吧，因为它能更好地处理 Unicode 文本。</blockquote><p class="calibre_">如果你运行这段代码，会得到一些像这样的推文：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>haithemnyc: Data scientists with the technical savvy &amp;amp; analytical chops to<br class="calibre12"/>derive meaning from big data are in demand. http://t.co/HsF9Q0dShP<br class="calibre12"/><br class="calibre12"/>RPubsRecent: Data Science http://t.co/6hcHUz2PHM<br class="calibre12"/><br class="calibre12"/>spleonard1: Using #dplyr in #R to work through a procrastinated assignment for<br class="calibre12"/>@rdpeng in @coursera data science specialization.  So easy and Awesome.<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这并不十分有趣，很大程度上是因为 Twitter Search API 只给你显示它认为最近的结果，无论内容有多么少。但对于数据科学工作，通常你需要大量的推文。这时，Streaming API（<a href="https://dev.twitter.com/streaming/reference/get/statuses/sample" class="calibre3">https://dev.twitter.com/streaming/reference/get/statuses/sample</a> ）就有用武之地了，它允许你连接到强大的 Twitter firehose 接口（的一个样本）。你需要使用访问令牌进行验证，才可以使用这个 API。</p><p class="calibre_">为了用 Twython 访问 Streaming API，需要定义一个从 <tt class="calibre7">TwythonStreamer</tt> 继承的类，并用这个类的 <tt class="calibre7">on_success</tt> 方法覆盖（当然也可能是用它的 <tt class="calibre7">on_error</tt> 方法来覆盖）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>from twython import TwythonStreamer<br class="calibre12"/><br class="calibre12"/># 把数据添加到全局变量是一种非常差的形式<br class="calibre12"/># 但会让这个例子更简单<br class="calibre12"/>tweets = []<br class="calibre12"/><br class="calibre12"/>class MyStreamer(TwythonStreamer):<br class="calibre12"/>    """our own subclass of TwythonStreamer that specifies<br class="calibre12"/>    how to interact with the stream"""<br class="calibre12"/><br class="calibre12"/>    def on_success(self, data):<br class="calibre12"/>        """what do we do when twitter sends us data?<br class="calibre12"/>        here data will be a Python dict representing a tweet"""<br class="calibre12"/><br class="calibre12"/>        # 只收集英文的推文<br class="calibre12"/>        if data['lang'] == 'en':<br class="calibre12"/>            tweets.append(data)<br class="calibre12"/>            print "received tweet #", len(tweets)<br class="calibre12"/><br class="calibre12"/>        # 当收集了足够多的推文就停止<br class="calibre12"/>        if len(tweets) &gt;= 1000:<br class="calibre12"/>            self.disconnect()<br class="calibre12"/><br class="calibre12"/>    def on_error(self, status_code, data):<br class="calibre12"/>        print status_code, data<br class="calibre12"/>        self.disconnect()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">MyStreamer 会连接到 Twitter 流并等待 Twitter 给它发送数据。它每收到一些数据（在这里，一条推文表示为一个 Python 对象）就传递给 <tt class="calibre7">on_success</tt> 方法，如果推文是英文的，这个方法会把推文附加到 <tt class="calibre7">tweets</tt> 列表中，在收集到 1000 条推文后会断开和流的连接。</p><p class="calibre_">剩下的工作就是初始化和启动运行了：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>stream = MyStreamer(CONSUMER_KEY, CONSUMER_SECRET,<br class="calibre12"/>                    ACCESS_TOKEN, ACCESS_TOKEN_SECRET)<br class="calibre12"/><br class="calibre12"/># 开始使用包含关键词'data'的公共状态<br class="calibre12"/>stream.statuses.filter(track='data')<br class="calibre12"/><br class="calibre12"/># 如果我们想使用*all*公共状态的样本<br class="calibre12"/># stream.statuses.sample()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">它会一直运行下去直到收集 1000 条推文为止（或直到遇到一个错误为止），此时就可以着手分析这些推文了。比如，你可以用下面的方法寻找最常见的标签：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>top_hashtags = Counter(hashtag['text'].lower()<br class="calibre12"/>                       for tweet in tweets<br class="calibre12"/>                       for hashtag in tweet["entities"]["hashtags"])<br class="calibre12"/><br class="calibre12"/>print top_hashtags.most_common(5)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">每条推文都包含许多数据。你可以自己尝试一下各种方法，或仔细查阅 Twitter API 的文档（<a href="https://dev.twitter.com/overview/api/tweets" class="calibre3">https://dev.twitter.com/overview/api/tweets</a> ）。</p><blockquote class="calibre_14"><img src="images/00100.jpg" class="calibre_10"/> 　在一个正式的项目中，你可能并不想依赖内存中的列表来存储推文。相反，你可能想把推文保存在文件或者数据库中，这样就可以永久地拥有它们。</blockquote><div class="mbp_pagebreak" id="calibre_pb_68"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
