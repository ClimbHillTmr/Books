<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos230916" class="calibre_"><span class="calibre6"><span class="bold"> 7.2　案例：掷硬币 </span></span></p><p class="calibre_">假设有一枚硬币，我们试图判断它是否均匀，即任何一面朝上的可能性是否相等。首先，假设硬币落地后正面朝上的概率为 <span class="italic">p</span> ，所以我们的零假设为硬币均匀，即 <span class="italic">p</span> =0.5。我们要对</p><p class="calibre_">比替代假设 <span class="italic">p</span> ≠0.5 来检验这个假设。</p><p class="calibre_">具体来说，首先掷硬币 <span class="italic">n</span> 次，将出现正面朝上的次数记为 <span class="italic">X</span> 。每次掷硬币都是一次伯努利试验，意味着 <span class="italic">X</span> 是二项式随机变量 Binomial(n,p)，（正如第 6 章中所讲到的）可以用正态分布来拟合：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def normal_approximation_to_binomial(n, p):<br class="calibre12"/>    """finds mu and sigma corresponding to a Binomial(n, p)"""<br class="calibre12"/>    mu = p * n<br class="calibre12"/>    sigma = math.sqrt(p * (1 - p) * n)<br class="calibre12"/>    return mu, sigma<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">只要一个随机变量服从正态分布，我们就可以用 <tt class="calibre7">normal_cdf</tt> 来计算出一个实现数值位于（或不在）某个特定区间的概率：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 正态cdf是一个变量在一个阈值以下的概率<br class="calibre12"/>normal_probability_below = normal_cdf<br class="calibre12"/><br class="calibre12"/># 如果它不在阈值以下，就在阈值之上<br class="calibre12"/>def normal_probability_above(lo, mu=0, sigma=1):<br class="calibre12"/>    return 1 - normal_cdf(lo, mu, sigma)<br class="calibre12"/><br class="calibre12"/># 如果它小于hi但不比lo小，那么它在区间之内<br class="calibre12"/>def normal_probability_between(lo, hi, mu=0, sigma=1):<br class="calibre12"/>    return normal_cdf(hi, mu, sigma) - normal_cdf(lo, mu, sigma)<br class="calibre12"/><br class="calibre12"/># 如果不在区间之内，那么就在区间之外<br class="calibre12"/>def normal_probability_outside(lo, hi, mu=0, sigma=1):<br class="calibre12"/>    return 1 - normal_probability_between(lo, hi, mu, sigma)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">或者反过来，找出非尾区域，或者找出均值两边的（对称）区域，这个区域恰好对应特定比例的可能性。比如，如果我们需要找出以均值为中心、覆盖 60% 可能性的区间，那我们需要找到两个截点，使上尾和下尾各覆盖 20% 的可能性（给中间留出 60%）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def normal_upper_bound(probability, mu=0, sigma=1):<br class="calibre12"/>    """returns the z for which P(Z &lt;= z) = probability"""<br class="calibre12"/>    return inverse_normal_cdf(probability, mu, sigma)<br class="calibre12"/><br class="calibre12"/>def normal_lower_bound(probability, mu=0, sigma=1):<br class="calibre12"/>    """returns the z for which P(Z &gt;= z) = probability"""<br class="calibre12"/>    return inverse_normal_cdf(1 - probability, mu, sigma)<br class="calibre12"/><br class="calibre12"/>def normal_two_sided_bounds(probability, mu=0, sigma=1):<br class="calibre12"/>    """returns the symmetric (about the mean) bounds<br class="calibre12"/>    that contain the specified probability"""<br class="calibre12"/>    tail_probability = (1 - probability) / 2<br class="calibre12"/><br class="calibre12"/>    # 上界应有在它之上的tail_probability<br class="calibre12"/>    upper_bound = normal_lower_bound(tail_probability, mu, sigma)<br class="calibre12"/><br class="calibre12"/>    # 下界应有在它之下的tail_probability<br class="calibre12"/>    lower_bound = normal_upper_bound(tail_probability, mu, sigma)<br class="calibre12"/><br class="calibre12"/>    return lower_bound, upper_bound<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">具体来讲，首先我们选择掷硬币 <span class="italic">n</span> =1000 次。如果关于均匀的原假设是正确的，那么 <span class="italic">X</span> 近似服从正态分布，均值为 50，标准差为 15.8：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>mu_0, sigma_0 = normal_approximation_to_binomial(1000, 0.5)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们需要对<span class="bold">显著性</span> （significance）下定义——我们有多大的可能性犯<span class="bold">第 1 类错误</span> （“容错”）。在这种情况下，我们拒绝了原假设 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">0</span></small></sub> ，但实际上原假设是正确的。出于历史上的某些原因，可能性的大小通常设定为 5% 或者 1%。本书在此选择 5%。</p><p class="calibre_">考虑这样的检验——如果 <span class="italic">X</span> 落在以下区间以外，就拒绝原假设 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">0</span></small></sub> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>normal_two_sided_bounds(0.95, mu_0, sigma_0) # (469, 531)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">假设 <span class="italic">p</span> 实际上等于 0.5（即，此时 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">0</span></small></sub> 成立），那么我们有 5% 的可能观测到 <span class="italic">X</span> 落在区间之外，这正是我们想要的显著性。换句话说，如果 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">0</span></small></sub> 为真，那么 20 次检验中大约有 19 次会得出正确的结果。</p><p class="calibre_">我们常常对检验的<span class="bold">势</span> （power）有兴趣，它指的是不犯<span class="bold">第 2 类错误</span> 的概率。第 2 类错误指原假设 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">0</span></small></sub> 是错的，但我们的检验结果没有拒绝原假设（即“纳伪”）。为了衡量统计的势，我们需要精确衡量 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">0</span></small></sub> 是错的<span class="bold">意味着什么</span> 。（仅仅知道 <span class="italic">p</span> 不是 0.5 不足以为 <span class="italic">X</span> 的分布提供足够的信息。）具体来说，假如 <span class="italic">p</span> 实际上是 0.55，那么掷硬币的结果会稍微多偏向正面朝上。</p><p class="calibre_">在这种情形下，我们这样计算检验的势：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 基于假设p是0.5时95%的边界<br class="calibre12"/>lo, hi = normal_two_sided_bounds(0.95, mu_0, sigma_0)<br class="calibre12"/><br class="calibre12"/># 基于p = 0.55的真实mu和sigma<br class="calibre12"/>mu_1, sigma_1 = normal_approximation_to_binomial(1000, 0.55)<br class="calibre12"/><br class="calibre12"/># 第2类错误意味着我们没有拒绝原假设<br class="calibre12"/># 这会在X仍然在最初的区间时发生<br class="calibre12"/>type_2_probability = normal_probability_between(lo, hi, mu_1, sigma_1)<br class="calibre12"/>power = 1 - type_2_probability      # 0.887<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果我们把原假设变为掷硬币的结果不会偏重于正面朝上，即 <span class="italic">P</span> ≤ 0.5，在这种情形下，我们使用<span class="bold">单边检验</span> 。如果 <span class="italic">X</span> 远大于 50，我们就拒绝原假设，如果 <span class="italic">X</span> 小于 50，就不拒绝原假设。因此，显著性为 5% 的检验需要使用 <tt class="calibre7">normal_probability_below</tt> 来找出小于 95% 的 概率对应的截点：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>hi = normal_upper_bound(0.95, mu_0, sigma_0)<br class="calibre12"/># 是526 (&lt; 531, 因为我们在上尾需要更多的概率)<br class="calibre12"/>type_2_probability = normal_probability_below(hi, mu_1, sigma_1)<br class="calibre12"/>power = 1 - type_2_probability      # 0.936<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这是更有效的检验。如果 <span class="italic">X</span> 小于 469，我们就不再拒绝 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">0</span></small></sub> （如果 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">1</span></small></sub> 为真，这不太可能发生），当 <span class="italic">X</span> 在 526 和 531 之间时则拒绝 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">0</span></small></sub> （如果 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">1</span></small></sub> 为真，这很有可能发生）。</p><p class="calibre_">进行上述检验的另一种方式涉及 <span class="italic">p</span>
<span class="bold">值</span> 。我们不再基于某个概率截点选择临界值，而是计算概率——假设 <span class="italic">H</span>
<sub class="calibre17"><small class="calibre9"><span class="calibre18">0</span></small></sub> 正确——我们可以找到一个至少与我们实际观测到的值一样极端的值。</p><p class="calibre_">对于硬币是否均匀的双面检验，我们可以做以下计算：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def two_sided_p_value(x, mu=0, sigma=1):<br class="calibre12"/>    if x &gt;= mu:<br class="calibre12"/>        # 如果x大于均值，tail表示比x大多少<br class="calibre12"/>        return 2 * normal_probability_above(x, mu, sigma)<br class="calibre12"/>    else:<br class="calibre12"/>        # 如果x比均值小，tail表示比x小多少<br class="calibre12"/>        return 2 * normal_probability_below(x, mu, sigma)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果我们希望看到结果中有 530 次为正面朝上，可以这样计算：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>two_sided_p_value(529.5, mu_0, sigma_0)  # 0.062<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><blockquote class="calibre_68"><img src="images/00100.jpg" class="calibre_10"/>
</blockquote><blockquote class="calibre_14">为什么我们用 529.5 而不用 530 ？这就是所谓的连续校正（continuity correction）。它反映了一个事实，即对从掷硬币结果中看到 530 次正面朝上的概率而言，<tt class="calibre7">normal_probability_between(529.5, 530.5, mu_0,sigma_0)</tt> 是比 <tt class="calibre7">normal_probability_between(530, 531, mu_0, sigma_0)</tt> 更好的估计。</blockquote><blockquote class="calibre_14">相应地，<tt class="calibre7">normal_probability_above(529.5, mu_0, sigma_0)</tt> 是看到至少 530 次正面朝上概率的更好估计。你可以在通过代码生成的图 6-4 中看到。</blockquote><p class="calibre_">验证这种观点是否合理的一个方法是模拟：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>extreme_value_count = 0<br class="calibre12"/>for _ in range(100000):<br class="calibre12"/>    num_heads = sum(1 if random.random() &lt; 0.5 else 0    # 正面朝上的计数<br class="calibre12"/>                    for _ in range(1000))                # 在1000次抛掷中<br class="calibre12"/>    if num_heads &gt;= 530 or num_heads &lt;= 470:             # 并计算达到极值的频率<br class="calibre12"/>        extreme_value_count += 1                         # 极值的频率<br class="calibre12"/><br class="calibre12"/>print extreme_value_count / 100000   # 0.062<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">因为 <span class="italic">p</span> 值大于 5% 的显著性，所以我们不能拒绝原假设。如果我们看到了 532 次正面朝上，那么相应的 <span class="italic">p</span> 值为：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>two_sided_p_value(531.5, mu_0, sigma_0) # 0.0463<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">它小于 5% 的显著性，因此我们拒绝原假设。它正好是和之前相同的检验，只是计算统计量的方法稍有不同。</p><p class="calibre_">同样，我们有：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>upper_p_value = normal_probability_above<br class="calibre12"/>lower_p_value = normal_probability_below<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">对于单边检验，如果我们看到 525 次正面朝上，那么可以计算：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>upper_p_value(524.5, mu_0, sigma_0)   # 0.061<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这意味着我们会拒绝原假设。如果我们看到 527 次正面朝上，相应计算如下：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>upper_p_value(526.5, mu_0, sigma_0)   # 0.047<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">根据结果，我们会拒绝原假设。</p><blockquote class="calibre_32"><img src="images/00110.jpg" class="calibre_11"/>
</blockquote><blockquote class="calibre_14">在调用函数 <tt class="calibre7">normal_probability_above</tt> 计算 <span class="italic">p</span> 值之前，需要确定你的数据大致上服从正态分布。数据科学的不良数据记录中充斥着差之毫厘失之千里的例子，原因在于“数据是正态分布的”，如果数据本身不是正态分布，那结果就毫无意义。</blockquote><blockquote class="calibre_14">对正态分布的检验方法有好几种，绘图是不错的首选方案。</blockquote><div class="mbp_pagebreak" id="calibre_pb_49"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
