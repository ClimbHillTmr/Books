<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos611272" class="calibre_"><span class="calibre6"><span class="bold"> 20.3　语法 </span></span></p><p class="calibre_">还有一种语言建模方法，那就是利用<span class="bold">语法规则</span> （grammar）来生成符合要求的句子。在小学的时候，我们就已经知道了词的词类及其组合方式。例如，如果你有一个非常糟糕的英语老师，你必定会认为句子都是由<span class="bold">名词</span> 后面跟<span class="bold">动词</span> 构成的。这样的话，如果给你一个由名词和动词组成的列表，你就可以根据这种规则来造句了。</p><p class="calibre_">下面，我们将定义一个稍微复杂的语法：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>grammar = {<br class="calibre12"/>    "_S"  : ["_NP _VP"],<br class="calibre12"/>    "_NP" : ["_N",<br class="calibre12"/>             "_A _NP _P _A _N"],<br class="calibre12"/>    "_VP" : ["_V",<br class="calibre12"/>             "_V _NP"],<br class="calibre12"/>    "_N"  : ["data science", "Python", "regression"],<br class="calibre12"/>    "_A"  : ["big", "linear", "logistic"],<br class="calibre12"/>    "_P"  : ["about", "near"],<br class="calibre12"/>    "_V"  : ["learns", "trains", "tests", "is"]<br class="calibre12"/>}<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们约定，以下划线开头的名称表示语法<span class="bold">规则</span> ，它们需要进一步展开；而其他名称是不需要进一步处理的<span class="bold">终端符号</span> 。</p><p class="calibre_">例如，<tt class="calibre7">"_S"</tt> 是“句子”规则，其产生一个 <tt class="calibre7">"_NP"</tt> （“名词短语”）规则，后面紧跟一个 <tt class="calibre7">"_VP"</tt> （“动词短语”）规则。</p><p class="calibre_">动词短语规则可能会产生一个 <tt class="calibre7">"_V"</tt> （“动词”）规则，也可能会产生一个动词规则继之以名词短语规则。</p><p class="calibre_">请注意，<tt class="calibre7">"_NP"</tt> 规则所生成的规则中也包括其自身。我们知道，语法是可以递归的，因此，尽管这里这些语法非常有限，但是照样能够产生无穷多不同的句子。</p><p class="calibre_">那么，我们如何通过这些语法来生成句子呢？我们不妨从一个包含句子规则的列表 <tt class="calibre7">["_S"]</tt> 着手。然后，我们将不断展开每一项规则，即从该规则的产物中随机选择一个来代替它。当我们的列表元素全部变成终端符号时，我们就可以停下来了。</p><p class="calibre_">举例来说，上述过程可能像下面这样：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>['_S']<br class="calibre12"/>['_NP','_VP']<br class="calibre12"/>['_N','_VP']<br class="calibre12"/>['Python','_VP']<br class="calibre12"/>['Python','_V','_NP']<br class="calibre12"/>['Python','trains','_NP']<br class="calibre12"/>['Python','trains','_A','_NP','_P','_A','_N']<br class="calibre12"/>['Python','trains','logistic','_NP','_P','_A','_N']<br class="calibre12"/>['Python','trains','logistic','_N','_P','_A','_N']<br class="calibre12"/>['Python','trains','logistic','data science','_P','_A','_N']<br class="calibre12"/>['Python','trains','logistic','data science','about','_A', '_N']<br class="calibre12"/>['Python','trains','logistic','data science','about','logistic','_N']<br class="calibre12"/>['Python','trains','logistic','data science','about','logistic','Python']<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们如何实现它呢？ 首先，我们需要创建一个简单的辅助函数来识别终端符号：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def is_terminal(token):<br class="calibre12"/>    return token[0] != "_"<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">接下来，我们需要编写一个函数，将一个标记列表变成一个句子。首先，我们需要找到第一个非终结符号标记。如果我们找不到这种标记，那就意味着我们已经有一个完整的句子，可以收工了。</p><p class="calibre_">如果我们真的找到了一个非终端符号，那么就在其产物中随机选择一个。如果选中的是个终端符号（即一个单词），那么直接用它替换相应的标记即可。除此之外，如果选中的是一个由空格符分隔的非终端符标记，那么则需要进行拆分，并将其拼接到当前标记中。总之，我们的工作就是在一组新标记上不断重复这个过程。</p><p class="calibre_">上述过程可以通过下列代码实现：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def expand(grammar, tokens):<br class="calibre12"/>    for i, token in enumerate(tokens):<br class="calibre12"/><br class="calibre12"/>        # 跳过终端符号<br class="calibre12"/>        if is_terminal(token): continue<br class="calibre12"/><br class="calibre12"/>        # 如果这一步我们发现了一个非终端符号<br class="calibre12"/>        # 需要随机选择一个替代者<br class="calibre12"/>        replacement = random.choice(grammar[token])<br class="calibre12"/><br class="calibre12"/>        if is_terminal(replacement):<br class="calibre12"/>            tokens[i] = replacement<br class="calibre12"/>        else:<br class="calibre12"/>            tokens = tokens[:i] + replacement.split() + tokens[(i+1):]<br class="calibre12"/><br class="calibre12"/>        # 现在展开新的符号列表<br class="calibre12"/>        return expand(grammar, tokens)<br class="calibre12"/><br class="calibre12"/>    # 如果到达这一步，就找出了所有的终端符号，可以收工了<br class="calibre12"/>    return tokens<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">现在我们可以生成句子了：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def generate_sentence(grammar):<br class="calibre12"/>    return expand(grammar, ["_S"])<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">只要我们不断改变语法——例如添加更多的单词、添加更多的规则、添加各种词类等——就能得到足够多的网页来满足公司的需要。</p><p class="calibre_">实际上，当语法用于另一个方向时，会变得更加有趣。给定一个句子，我们就可以用语法来<span class="bold">解析</span> 句子。这就能帮助我们识别主语和动词，从而理解句子的含义。</p><p class="calibre_">用数据科学来生成文本的确是个妙招，但更神奇的是，它还可以用来<span class="bold">理解</span> 文本。（这方面的程序库请参阅 16.6 节“延伸学习”部分。）</p><div class="mbp_pagebreak" id="calibre_pb_143"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
