<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos539220" class="calibre_"><span class="calibre6"><span class="bold"> 18.1　感知器 </span></span></p><p class="calibre_">
<span class="bold">感知器</span> （perception）可能是最简单的神经网络了，或者说是由具有 <span class="italic">n</span> 个二进制输入的单个神经元所组成的神经网络。感知器首先会对输入值加权求和，如果加权和大于等于 0，它就会被激活：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def step_function(x):<br class="calibre12"/>    return 1 if x &gt;= 0 else 0<br class="calibre12"/><br class="calibre12"/>def perceptron_output(weights, bias, x):<br class="calibre12"/>    """returns 1 if the perceptron 'fires', 0 if not"""<br class="calibre12"/>    calculation = dot(weights, x) + bias<br class="calibre12"/>    return step_function(calculation)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">实际上，感知器只是根据点 <tt class="calibre7">x</tt> 的超平面将问题空间分隔为两部分而已：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>dot(weights,x) + bias == 0<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">通过正确选用权值，感知器能解决许多简单的问题（图 18-1）。例如，我们可以创建一个<span class="bold">与门</span> （即 AND，也就是说，当两个输入都为 1 时，返回 1；只要输入有一个为 0 时，返回 0），代码如下所示：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>weights = [2, 2]<br class="calibre12"/>bias = -3<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果两个输入都为 1，则计算结果为 2 + 2 - 3 = 1，所以输出为 1。但是，只要输入中有一个为 0，则计算结果为 2 + 0 - 3 = -1，所以输出为 0。同时，如果两个输入都为 0，则计算结果为 -3，所以输出还是 0。同样，我们还可以建立一个<span class="bold">或门</span> （OR），代码如下所示：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>weights = [2, 2]<br class="calibre12"/>bias = -1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_19"><img src="images/00010.jpg" class="calibre_136"/>
</p><p class="calibre_">
<span class="bold">图 18-1：双输入感知器的决策空间</span>
</p><p class="calibre_">同样，我们还可以建立一个<span class="bold">非门</span> （即 NOT，它只有一个输入端，并且会把输入的 1 转换为 0，反之亦然），代码如下所示：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>weights = [-2]<br class="calibre12"/>bias = 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">不过，有些问题是单个感知器所无法解决的，比如，无论你如何尝试，都无法通过一个感知器来构建<span class="bold">异或门</span> （XOR），即两个输入不同时输出为 1，否则输出为 0。这种情况下，我们就需要使用更加复杂的神经网络了。</p><p class="calibre_">当然，在建立逻辑门的时候，根本无需惟妙惟肖地模仿神经元，看一眼下面的代码你就明白了：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>and_gate = min<br class="calibre12"/>or_gate = max<br class="calibre12"/>xor_gate = lambda x, y: 0 if x == y else 1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">就像真实的神经元那样，当你将它们连接起来时，就会发生许多有趣的事情。</p><div class="mbp_pagebreak" id="calibre_pb_127"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
