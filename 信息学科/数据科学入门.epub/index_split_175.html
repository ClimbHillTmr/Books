<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos746990" class="calibre_15"><span class="calibre6"><span class="bold"> 24.4　案例：分析状态更新 </span></span></p><p class="calibre_">内容部门的副总对单词计数印象深刻，并询问你还能从用户的状态更新中学到什么。你设法提取了一个类似下面这样的状态更新的数据集：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>{"id": 1,<br class="calibre12"/> "username" : "joelgrus",<br class="calibre12"/> "text" : "Is anyone interested in a data science book?",<br class="calibre12"/> "created_at" : datetime.datetime(2013, 12, 21, 11, 47, 0),<br class="calibre12"/> "liked_by" : ["data_guy", "data_gal", "mike"] }<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">假设我们想找出每周内的哪一天人们讨论数据科学最多。为了找到这个结果，只需计算一下一周内每一天有多少个数据科学更新。这意味着我们需要按每周内的每天进行分组，这就是我们的键。而且如果对每一个包含“数据科学”的更新发送一个值 <tt class="calibre7">1</tt> ，就可以使用 <tt class="calibre7">sum</tt> 函数得到总数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def data_science_day_mapper(status_update):<br class="calibre12"/>    """yields (day_of_week, 1) if status_update contains "data science" """<br class="calibre12"/>    if "data science" in status_update["text"].lower():<br class="calibre12"/>        day_of_week = status_update["created_at"].weekday()<br class="calibre12"/>        yield (day_of_week, 1)<br class="calibre12"/><br class="calibre12"/>data_science_days = map_reduce(status_updates,<br class="calibre12"/>                               data_science_day_mapper,<br class="calibre12"/>                               sum_reducer)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">再举一个稍微复杂一点的例子，假设我们需要找出每个用户在其状态更新中最常用的单词是什么。为了建立 <tt class="calibre7">mapper</tt> ，我们的脑海中会浮现以下三种方法。</p><div class="calibre_5"> </div><ul class="calibre_6"><li value="1" class="calibre_7"><p class="calibre_">把用户名放到键当中；把单词和计数放到值当中。</p></li><li value="2" class="calibre_8"><p class="calibre_">把单词放到键当中；把用户名和计数放到值当中。</p></li><li value="3" class="calibre_8"><p class="calibre_">把用户名和单词放到键当中；把计数放到值当中。</p></li></ul><p class="calibre_">稍作考虑，我们很容易就能判断出应该按 <tt class="calibre7">username</tt> 分组，因为我们想分别考虑每个人的单词。而且我们不想用 <tt class="calibre7">word</tt> 来分组，因为我们的 reducer 需要看到每个人所有的词汇，以此找到哪一个是最流行的。这意味着第一种选择是最优选择：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def words_per_user_mapper(status_update):<br class="calibre12"/>    user = status_update["username"]<br class="calibre12"/>    for word in tokenize(status_update["text"]):<br class="calibre12"/>        yield (user, (word, 1))<br class="calibre12"/><br class="calibre12"/>def most_popular_word_reducer(user, words_and_counts):<br class="calibre12"/>    """given a sequence of (word, count) pairs,<br class="calibre12"/>    return the word with the highest total count"""<br class="calibre12"/><br class="calibre12"/>    word_counts = Counter()<br class="calibre12"/>    for word, count in words_and_counts:<br class="calibre12"/>        word_counts[word] += count<br class="calibre12"/><br class="calibre12"/>    word, count = word_counts.most_common(1)[0]<br class="calibre12"/><br class="calibre12"/>    yield (user, (word, count))<br class="calibre12"/><br class="calibre12"/>user_words = map_reduce(status_updates,<br class="calibre12"/>                        words_per_user_mapper,<br class="calibre12"/>                        most_popular_word_reducer)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">或者我们能为每个用户找到各自的状态点赞者的个数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def liker_mapper(status_update):<br class="calibre12"/>    user = status_update["username"]<br class="calibre12"/>    for liker in status_update["liked_by"]:<br class="calibre12"/>        yield (user, liker)<br class="calibre12"/><br class="calibre12"/>distinct_likers_per_user = map_reduce(status_updates,<br class="calibre12"/>                                      liker_mapper,<br class="calibre12"/>                                      count_distinct_reducer)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><div class="mbp_pagebreak" id="calibre_pb_175"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
