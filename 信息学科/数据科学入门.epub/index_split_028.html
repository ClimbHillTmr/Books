<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos152659" class="calibre_"><span class="calibre6"><span class="bold"> 4.1　向量 </span></span></p><p class="calibre_">抽象地说，<span class="bold">向量</span> 是指可以加总（以生成新的向量），可以乘以<span class="bold">标量</span> （即数字），也可以生成新的向量的对象。</p><p class="calibre_">具体来说（对我们而言），向量是有限维空间的点。即使你本无意视你的数据为向量，将数值数据表示为向量也是非常好的处理方式。</p><p class="calibre_">比如，如果你有很多人的身高、体重、年龄数据，就可以把数据记为三维向量 <tt class="calibre7">(height, weight, age)</tt> 。如果你教的一个班有四门考试，就可以把学生成绩记为四维向量 <tt class="calibre7">(exam1, exam2, exam3, exam4)</tt> 。</p><p class="calibre_">最简单的入门方法是将向量表示为数字的列表。一个包含三个数字的列表对应一个三维空间的向量，反之亦然：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>height_weight_age = [70,  # 英寸<br class="calibre12"/>                     170, # 磅<br class="calibre12"/>                     40 ] # 岁<br class="calibre12"/><br class="calibre12"/>grades = [95,  # 考试1<br class="calibre12"/>          80,  # 考试2<br class="calibre12"/>          75,  # 考试3<br class="calibre12"/>          62 ] # 考试4<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这种方式的一个问题在于向量<span class="bold">算法</span> 的应用。由于 Python 中的列表不同于向量（因此无法直接对向量运算），我们需要自己提前构建相应算法工具。现在就开始构建吧！</p><p class="calibre_">首先，我们常常需要对两个向量做加法。向量以<span class="bold">分量方式</span> （componentwise）做运算。这意味着，如果两个向量 <tt class="calibre7">v</tt> 和 <tt class="calibre7">w</tt> 长度相同，那它们的和就是一个新的向量，其中向量的第一个元素等于 <tt class="calibre7">v[0] + w[0]</tt> ，第二个元素等于 <tt class="calibre7">v[1] + w[1]</tt> ，以此类推。（如果两个向量长度不同，则不能相加。）</p><p class="calibre_">例如，向量 <tt class="calibre7">[1, 2]</tt> 加上向量 <tt class="calibre7">[2, 1]</tt> 等于 <tt class="calibre7">[1 + 2, 2 + 1]</tt> 或 <tt class="calibre7">[3, 3]</tt> ，如图 4-1 所示。</p><p class="calibre_12"><img src="images/00143.jpg" class="calibre_29"/>
</p><p class="calibre_">
<span class="bold">图 4-1：两个向量相加</span>
</p><p class="calibre_">我们可以很容易地实现这个功能：对向量调用 <tt class="calibre7">zip</tt> 函数，同时用列表解析使向量的相应元素相加：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def vector_add(v, w):<br class="calibre12"/>    """adds corresponding elements"""<br class="calibre12"/>    return [v_i + w_i<br class="calibre12"/>            for v_i, w_i in zip(v, w)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">同样，对两个向量做减法，只需要使向量的相应元素相减：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def vector_subtract(v, w):<br class="calibre12"/>    """subtracts corresponding elements"""<br class="calibre12"/>    return [v_i - w_i<br class="calibre12"/>            for v_i, w_i in zip(v, w)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">有时，我们需要对一系列向量做加法。即生成一个新向量，其第一个元素是这一系列向量第一个元素的和，第二个元素是这一系列向量第二个元素的和，以此类推。最简单的方法是每次递加一个向量：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def vector_sum(vectors):<br class="calibre12"/>    """sums all corresponding elements"""<br class="calibre12"/>    result = vectors[0]                                # 从第一个向量开始<br class="calibre12"/>    for vector in vectors[1:]:                         # 之后遍历其他向量<br class="calibre12"/>        result = vector_add(result, vector)            # 最后计入总和<br class="calibre12"/>    return result<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">当你思考这个解决方法时，我们正通过 <tt class="calibre7">vector_add</tt> 函数，即使用 <tt class="calibre7">reduce</tt> 的方式来加总这一系列的向量。换句话说，我们用高级的函数更加简洁地实现了这个功能：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def vector_sum(vectors):<br class="calibre12"/>    return reduce(vector_add, vectors)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">或者：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>vector_sum = partial(reduce, vector_add)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这最后一种方法很简洁、巧妙，但可能相比之下没有前几种有用处。</p><p class="calibre_">当然，我们有时也需要给一个向量乘以一个标量，这时只需将向量的每个元素乘以那个数字：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def scalar_multiply(c, v):<br class="calibre12"/>    """c is a number, v is a vector"""<br class="calibre12"/>    return [c * v_i for v_i in v]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们也可以计算一系列向量（长度相同）的均值：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def vector_mean(vectors):<br class="calibre12"/>    """compute the vector whose ith element is the mean of the<br class="calibre12"/>    ith elements of the input vectors"""<br class="calibre12"/>    n = len(vectors)<br class="calibre12"/>    return scalar_multiply(1/n, vector_sum(vectors))<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">一个不常见的功能是<span class="bold">点乘</span> （dot product）。两个向量的点乘表示对应元素的分量乘积之和：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def dot(v, w):<br class="calibre12"/>    """v_1 * w_1 + ... + v_n * w_n"""<br class="calibre12"/>    return sum(v_i * w_i<br class="calibre12"/>               for v_i, w_i in zip(v, w))<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">点乘衡量了向量 <span class="italic">v</span> 在向量 <span class="italic">w</span> 方向延伸的程度。例如，如果 <tt class="calibre7">w=[1, 0]</tt> ，则 <tt class="calibre7">dot(v, w)</tt> 就是 <tt class="calibre7">v</tt> 的第一个元素。点乘的另一个解释是将 <span class="italic">v</span> 在 <span class="italic">w</span> 上<span class="bold">投影</span> 所得到的向量的长度（如图 4-2）：</p><p class="calibre_12"><img src="images/00153.jpg" class="calibre_30"/>
</p><p class="calibre_">
<span class="bold">图 4-2：点乘即向量投影</span>
</p><p class="calibre_">通过点乘很容易计算一个向量的平方和：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def sum_of_squares(v):<br class="calibre12"/>    """v_1 * v_1 + ... + v_n * v_n"""<br class="calibre12"/>    return dot(v, v)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">可以用来计算向量的<span class="bold">大小</span> （或长度）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import math<br class="calibre12"/><br class="calibre12"/>def magnitude(v):<br class="calibre12"/>    return math.sqrt(sum_of_squares(v))     # math.sqrt是平方根函数<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">现在，我们得到了为计算两个向量的距离所需要的所有部分，定义如下：</p><p class="calibre_12"><img src="images/00002.jpg" class="calibre_31"/>
</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def squared_distance(v, w):<br class="calibre12"/>    """(v_1 - w_1) ** 2 + ... + (v_n - w_n) ** 2"""<br class="calibre12"/>    return sum_of_squares(vector_subtract(v, w))<br class="calibre12"/><br class="calibre12"/>def distance(v, w):<br class="calibre12"/>   return math.sqrt(squared_distance(v, w))<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">写成下式（与上式等价）更清晰：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def distance(v, w):<br class="calibre12"/>    return magnitude(vector_subtract(v, w))<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">有了这些关于向量的概念和计算，我们就可以开始探讨数据科学了。本书后续部分会大量使用这些概念。</p><blockquote class="calibre_32"><img src="images/00100.jpg" class="calibre_10"/>
</blockquote><blockquote class="calibre_14">用列表来表示向量很有利于概念阐释，但对性能却影响很糟。</blockquote><blockquote class="calibre_14">实际编程中，你需要使用 NumPy 库。这个库中有包含各种算法操作的高性能数组类。</blockquote><div class="mbp_pagebreak" id="calibre_pb_28"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
