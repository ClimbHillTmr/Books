<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos348092" class="calibre_"><span class="calibre6"><span class="bold"> 10.3　数据处理 </span></span></p><p class="calibre_">数据科学家的核心技能之一就是<span class="bold">处理数据</span> 。与其说它是一种特定的技术，不如说它是一种通用的方法，所以这里我们只通过一些例子窥其一二。</p><p class="calibre_">假设我们需要处理如下股票价格字典：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>data = [<br class="calibre12"/>    {'closing_price': 102.06,<br class="calibre12"/>     'date': datetime.datetime(2014, 8, 29, 0, 0),<br class="calibre12"/>     'symbol': 'AAPL'},<br class="calibre12"/>    # ...<br class="calibre12"/>]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们可以从概念上将它们理解为行（就像在一张表中）。</p><p class="calibre_">我们开始对这些数据发问。在这个过程中，我们会不断关注做事所使用的模式，并抽象出一些工具以使数据的处理更容易些。</p><p class="calibre_">比如，如果我们想知道 AAPL 有史以来的最高收盘价，可以将这个工作分解成具体的步骤：</p><p class="calibre_">(1) 将数据限定在 AAPL 行上；</p><p class="calibre_">(2) 从每行提取收盘价 <tt class="calibre7">closing_price</tt> ；</p><p class="calibre_">(3) 取价格中的最大值 <tt class="calibre7">max</tt> 。</p><p class="calibre_">我们可以使用一个列表解析一次性完成这三个步骤：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>max_aapl_price = max(row["closing_price"]<br class="calibre12"/>                     for row in data<br class="calibre12"/>                     if row["symbol"] == "AAPL")<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">更一般地，我们也许希望知道数据集中每只股票的最高收盘价。一个方法如下所示。</p><p class="calibre_">(1) 聚集起股票代码（<tt class="calibre7">symbol</tt> ）相同的行。</p><p class="calibre_">(2) 在每组中，重复之前的工作：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 按股票代码对行分组<br class="calibre12"/>by_symbol = defaultdict(list)<br class="calibre12"/>for row in data:<br class="calibre12"/>    by_symbol[row["symbol"]].append(row)<br class="calibre12"/><br class="calibre12"/># 使用字典解析找到每个股票代码的最大值<br class="calibre12"/>max_price_by_symbol = { symbol : max(row["closing_price"]<br class="calibre12"/>                                     for row in grouped_rows)<br class="calibre12"/>                        for symbol, grouped_rows in by_symbol.iteritems() }<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">有一些模式已经存在。在以上两个例子中，我们需要在每个字典 <tt class="calibre7">dict</tt> 中提取出收盘价 <tt class="calibre7">closing_price</tt> 。因而我们可以创建一个函数，以从字典中提取一个字段，并创建另一个函数，以从字典集合中提取出同样的字段：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def picker(field_name):<br class="calibre12"/>    """returns a function that picks a field out of a dict"""<br class="calibre12"/>    return lambda row: row[field_name]<br class="calibre12"/><br class="calibre12"/>def pluck(field_name, rows):<br class="calibre12"/>    """turn a list of dicts into the list of field_name values"""<br class="calibre12"/>    return map(picker(field_name), rows)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们同样可以建立一个函数，通过 <tt class="calibre7">group</tt> 函数的结果把行分组，并选择性地对每组使用 <tt class="calibre7">value_transform</tt> 函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def group_by(grouper, rows, value_transform=None):<br class="calibre12"/>    # 键是分组情况的输出，值是行的列表<br class="calibre12"/>    grouped = defaultdict(list)<br class="calibre12"/>    for row in rows:<br class="calibre12"/>        grouped[grouper(row)].append(row)<br class="calibre12"/><br class="calibre12"/>    if value_transform is None:<br class="calibre12"/>        return grouped<br class="calibre12"/>    else:<br class="calibre12"/>        return { key : value_transform(rows)<br class="calibre12"/>                 for key, rows in grouped.iteritems() }<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">这使得我们可以更简单地再现先前的例子。比如：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>max_price_by_symbol = group_by(picker("symbol"),<br class="calibre12"/>                               data,<br class="calibre12"/>                               lambda rows: max(pluck("closing_price", rows)))<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">现在我们可以问一些更复杂的问题，比如在我们的数据集中，单日百分比变动的最大值和最小值分别是什么。百分比变动的公式是 <tt class="calibre7">price_today/price_yesterday - 1</tt> （即今天的价格／昨天的价格 -1）。这意味着我们需要用某种方式将今天的价格和昨天的价格联系起来。一种方法是按照符号将价格分组，再在每组中：</p><p class="calibre_">(1) 按照日期排列价格；</p><p class="calibre_">(2) 通过命令 <tt class="calibre7">zip</tt> 得到配对价格（前一天的，今天的）；</p><p class="calibre_">(3) 将配对价格转换为新的“百分比变动”行。</p><p class="calibre_">我们首先写一个函数，来完成每一组内的工作：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def percent_price_change(yesterday, today):<br class="calibre12"/>    return today["closing_price"] / yesterday["closing_price"] - 1<br class="calibre12"/><br class="calibre12"/>def day_over_day_changes(grouped_rows):<br class="calibre12"/>    # 按日期对行排序<br class="calibre12"/>    ordered = sorted(grouped_rows, key=picker("date"))<br class="calibre12"/><br class="calibre12"/>    # 对偏移量应用zip函数得到连续两天的成对表示<br class="calibre12"/>    return [{ "symbol" : today["symbol"],<br class="calibre12"/>              "date" : today["date"],<br class="calibre12"/>              "change" : percent_price_change(yesterday, today) }<br class="calibre12"/>            for yesterday, today in zip(ordered, ordered[1:])]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">然后我们可以将它作为 <tt class="calibre7">value_transform</tt> 在 <tt class="calibre7">group_by</tt> 中使用：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 键是股票代码，值是一个"change"字典的列表<br class="calibre12"/>changes_by_symbol = group_by(picker("symbol"), data, day_over_day_changes)<br class="calibre12"/><br class="calibre12"/># 收集所有"change"字典放入一个大列表中<br class="calibre12"/>all_changes = [change<br class="calibre12"/>               for changes in changes_by_symbol.values()<br class="calibre12"/>               for change in changes]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">在这个点上，很容易找到最大值与最小值：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>max(all_changes, key=picker("change"))<br class="calibre12"/># {'change': 0.3283582089552237,<br class="calibre12"/>#  'date': datetime.datetime(1997, 8, 6, 0, 0),<br class="calibre12"/>#  'symbol': 'AAPL'}<br class="calibre12"/># see, e.g. http://news.cnet.com/2100-1001-202143.html<br class="calibre12"/>min(all_changes, key=picker("change"))<br class="calibre12"/># {'change': -0.5193370165745856,<br class="calibre12"/>#  'date': datetime.datetime(2000, 9, 29, 0, 0),<br class="calibre12"/>#  'symbol': 'AAPL'}<br class="calibre12"/># see, e.g. http://money.cnn.com/2000/09/29/markets/techwrap/<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">现在我们可以使用这个新的 <tt class="calibre7">all_changes</tt> 数据集来找出投资科技股的最佳月份。首先按月份对变化分组；然后在每组中计算整体变化。</p><p class="calibre_">我们再次写一个恰当的 <tt class="calibre7">value_transform</tt> 函数，然后使用 <tt class="calibre7">group_by</tt> 函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 为了组合百分比的变化，我们对每一项加1，把它们相乘，再减去1<br class="calibre12"/># 比如，如果我们组合 +10% 和 -20%, 总体的改变是<br class="calibre12"/>#    (1 + 10%) * (1 - 20%) - 1 = 1.1 * .8 - 1 = -12%<br class="calibre12"/>def combine_pct_changes(pct_change1, pct_change2):<br class="calibre12"/>    return (1 + pct_change1) * (1 + pct_change2) - 1<br class="calibre12"/><br class="calibre12"/>def overall_change(changes):<br class="calibre12"/>    return reduce(combine_pct_changes, pluck("change", changes))<br class="calibre12"/><br class="calibre12"/>overall_change_by_month = group_by(lambda row: row['date'].month,<br class="calibre12"/>                                   all_changes,<br class="calibre12"/>                                   overall_change)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">类似这样的数据处理方式将会贯穿全书，但它常常不会明显地引起我们的注意。</p><div class="mbp_pagebreak" id="calibre_pb_73"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
