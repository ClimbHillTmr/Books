<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos287400" class="calibre_"><span class="calibre6"><span class="bold"> 9.2　读取文件 </span></span></p><p class="calibre_">可以显式地用代码来读写文件。用 Python 处理文件非常简便。</p><p id="filepos287593" class="calibre_"><span class="calibre6"><span class="bold"> 9.2.1　文本文件基础 </span></span></p><p class="calibre_">处理文本文件的第一步是通过 <tt class="calibre7">open</tt> 命令来获取一个<span class="bold">文件对象</span> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 'r' 意味着只读<br class="calibre12"/>file_for_reading = open('reading_file.txt', 'r')<br class="calibre12"/><br class="calibre12"/># 'w' 是写入——会破坏已存在的文件!<br class="calibre12"/>file_for_writing = open('writing_file.txt', 'w')<br class="calibre12"/><br class="calibre12"/># 'a' 是添加——加入到文件的末尾<br class="calibre12"/>file_for_appending = open('appending_file.txt', 'a')<br class="calibre12"/><br class="calibre12"/># 完成以后别忘了关闭文件<br class="calibre12"/>file_for_writing.close()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">因为非常容易忘记关闭文件，所以你应该在 <tt class="calibre7">with</tt> 程序块里操作文件，这样在结尾处文件会被自动关闭：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>with open(filename,'r') as f:<br class="calibre12"/>    data = function_that_gets_data_from(f)<br class="calibre12"/><br class="calibre12"/># 此时，f已经关闭了，别再试图使用它<br class="calibre12"/>process(data)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果需要读取一个完整的文本文件，可以使用 <tt class="calibre7">for</tt> 语句对文件的行进行迭代：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>starts_with_hash = 0<br class="calibre12"/><br class="calibre12"/>with open('input.txt','r') as f:<br class="calibre12"/>    for line in file:              # 查找文件中的每一行<br class="calibre12"/>        if re.match("^#",line):    # 用正则表达式判断它是否以'#'开头<br class="calibre12"/>            starts_with_hash += 1  # 如果是，计数加1<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">按这种方法得到的每一行会用换行符来结尾，所以在对读入的行操作之前会经常需要用 <tt class="calibre7">strip()</tt> 来进行处理。</p><p class="calibre_">例如，假设你有一个写满电子邮件地址的文件，每个地址一行，你想利用这个文件生成域名的直方图。正确地提取域名的规则有些微妙（如公共后缀列表，<a href="https://publicsuffix.org/" class="calibre3">https://publicsuffix.org/</a> ），但一个好的近似方案是只取出电子邮件地址中 @ 后面的部分。（对于像 joel@mail.datasciencester.com 这样的邮件地址，会给出错误的答案。）</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def get_domain(email_address):<br class="calibre12"/>    """split on '@' and return the last piece"""<br class="calibre12"/>    return email_address.lower().split("@")[-1]<br class="calibre12"/><br class="calibre12"/>with open('email_addresses.txt', 'r') as f:<br class="calibre12"/>    domain_counts = Counter(get_domain(line.strip())<br class="calibre12"/>                            for line in f<br class="calibre12"/>                            if "@" in line)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p id="filepos290727" class="calibre_15"><span class="calibre6"><span class="bold"> 9.2.2　限制的文件 </span></span></p><p class="calibre_">我们刚刚处理的假想电子邮件地址文件每行只有一个地址。更常见的情况是你会处理每一行包含许多数据的文件。这种文件通常是用<span class="bold">逗号分割</span> 或 <span class="bold">tab 分割</span> 的，每一行有许多字段，用逗号（或 tab）来表示一个字段的结束和另一个字段的开始。</p><p class="calibre_">这开始变得复杂了，各字段中带有逗号、tab 和换行符（这是你不可避免地要处理的）。因为这个原因，几乎总是会犯的一个错误是你自己尝试去解析它们。相反，你应该使用 Python 的 <tt class="calibre7">csv</tt> 模块（或者 <tt class="calibre7">pandas</tt> 库）。出于微软方面（你可以对其大加责备）的技术原因，你应该总是通过把 <span class="italic">b</span> 包括在 <span class="italic">r</span> 或 <span class="italic">w</span> 之后来用二进制模式处理 <tt class="calibre7">csv</tt> 文件（见 Stack Overflow，<a href="http://stackoverflow.com/questions/4249185/using-python-to-append-csv-files" class="calibre3">http://stackoverflow.com/questions/4249185/using-python-to-append-csv-files</a> ）。</p><p class="calibre_">如果文件没有头部（意味着你可能想把每一行作为一个列表，这带来的麻烦是你需要知道每一列是什么），你可以使用 <tt class="calibre7">csv.reader</tt> 对行进行迭代，每一行都会被处理成恰当划分的列表。</p><p class="calibre_">例如，如果有这样一个用 tab 划分的股票价格文件：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>6/20/2014   AAPL    90.91<br class="calibre12"/>6/20/2014   MSFT    41.68<br class="calibre12"/>6/20/2014   FB  64.5<br class="calibre12"/>6/19/2014   AAPL    91.86<br class="calibre12"/>6/19/2014   MSFT    41.51<br class="calibre12"/>6/19/2014   FB  64.34<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们可以用下面的程序块来处理：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import csv<br class="calibre12"/><br class="calibre12"/>with open('tab_delimited_stock_prices.txt', 'rb') as f:<br class="calibre12"/>    reader = csv.reader(f, delimiter='\t')<br class="calibre12"/>    for row in reader:<br class="calibre12"/>        date = row[0]<br class="calibre12"/>        symbol = row[1]<br class="calibre12"/>        closing_price = float(row[2])<br class="calibre12"/>        process(date, symbol, closing_price)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果文件存在头部：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>date:symbol:closing_price<br class="calibre12"/>6/20/2014:AAPL:90.91<br class="calibre12"/>6/20/2014:MSFT:41.68<br class="calibre12"/>6/20/2014:FB:64.5<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你既可以跳过头部的行（利用对 <tt class="calibre7">read.next()</tt> 的初始调用）也可以利用 <tt class="calibre7">csv.DictReader</tt> 把每一行读成字典（把头部作为关键字）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>with open('colon_delimited_stock_prices.txt', 'rb') as f:<br class="calibre12"/>    reader = csv.DictReader(f, delimiter=':')<br class="calibre12"/>    for row in reader:<br class="calibre12"/>        date = row["date"]<br class="calibre12"/>        symbol = row["symbol"]<br class="calibre12"/>        closing_price = float(row["closing_price"])<br class="calibre12"/>        process(date, symbol, closing_price)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">即使你的文件缺少头部，你仍可以通过把关键字作为文件名参数传输来使用 <tt class="calibre7">DictReader</tt> 。</p><p class="calibre_">同样，你可以用 <tt class="calibre7">csv.writer</tt> 来写限制的文件：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>today_prices = { 'AAPL' : 90.91, 'MSFT' : 41.68, 'FB' : 64.5 }<br class="calibre12"/><br class="calibre12"/>with open('comma_delimited_stock_prices.txt','wb') as f:<br class="calibre12"/>    writer = csv.writer(f, delimiter=',')<br class="calibre12"/>    for stock, price in today_prices.items():<br class="calibre12"/>        writer.writerow([stock, price])<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果行中的各字段本身包含逗号，<tt class="calibre7">csv.writer</tt> 可以正确处理。但你自己手动写成的则很可能不会正确处理。比如，如果你尝试这样做：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>results = [["test1", "success", "Monday"],<br class="calibre12"/>           ["test2", "success, kind of", "Tuesday"],<br class="calibre12"/>           ["test3", "failure, kind of", "Wednesday"],<br class="calibre12"/>           ["test4", "failure, utter", "Thursday"]]<br class="calibre12"/><br class="calibre12"/># 不要这么做!<br class="calibre12"/>with open('bad_csv.txt', 'wb') as f:<br class="calibre12"/>    for row in results:<br class="calibre12"/>        f.write(",".join(map(str, row))) # 可能包含了太多逗号！<br class="calibre12"/>        f.write("\n")                    # 行也可能会换行！<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你最终会得到像下面这样一个 <tt class="calibre7">csv</tt> 文件：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>test1,success,Monday<br class="calibre12"/>test2,success, kind of,Tuesday<br class="calibre12"/>test3,failure, kind of,Wednesday<br class="calibre12"/>test4,failure, utter,Thursday<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">没人能看懂它的意思。</p><div class="mbp_pagebreak" id="calibre_pb_65"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
