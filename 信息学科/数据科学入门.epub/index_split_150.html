<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos669394" class="calibre_"><span class="calibre6"><span class="bold"> 21.3　有向图与PageRank </span></span></p><p class="calibre_">由于 DataSciencester 没有获得人们的热烈追捧，因此，负责营收的副总决定将网站从交友模式转换为赞助模式。事实证明，除了高科技业的猎头非常关心哪些数据科学家备受其他数据科学家推崇之外，没人对科学家之间的好友关系特别在意。</p><p class="calibre_">在这个新的模型中，我们所关注的赞助 <tt class="calibre7">(source, target)</tt> 并不表示互反关系，而是表示用户 <tt class="calibre7">source</tt> 认为用户 <tt class="calibre7">target</tt> 是一位令人惊畏的数据科学家（见图 21-5）。因此，我们需要考虑这种不对称性：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>endorsements = [(0, 1), (1, 0), (0, 2), (2, 0), (1, 2),<br class="calibre12"/>                (2, 1), (1, 3), (2, 3), (3, 4), (5, 4),<br class="calibre12"/>                (5, 6), (7, 5), (6, 8), (8, 7), (8, 9)]<br class="calibre12"/><br class="calibre12"/>for user in users:<br class="calibre12"/>    user["endorses"] = []       # 增加一个列表来追踪外方的赞助<br class="calibre12"/>    user["endorsed_by"] = []    # 增加另外一个列表来追踪赞助<br class="calibre12"/><br class="calibre12"/>for source_id, target_id in endorsements:<br class="calibre12"/>    users[source_id]["endorses"].append(users[target_id])<br class="calibre12"/>    users[target_id]["endorsed_by"].append(users[source_id])<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_19"><img src="images/00097.jpg" class="calibre_16"/>
</p><p class="calibre_">
<span class="bold">图 21-5：基于赞助关系的 DataSciencester 网络</span>
</p><p class="calibre_">这样的话，我们就能够轻而易举地找出 <tt class="calibre7">most_endorsed</tt> （最受推崇的）数据科学家，从而将这些信息出售给猎头们：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>endorsements_by_id = [(user["id"], len(user["endorsed_by"]))<br class="calibre12"/>                      for user in users]<br class="calibre12"/><br class="calibre12"/>sorted(endorsements_by_id,<br class="calibre12"/>       key=lambda (user_id, num_endorsements): num_endorsements,<br class="calibre12"/>       reverse=True)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">然而，“赞同票数”这种指标是很容易被人搞鬼的。实际上，你只要创建大量傀儡账户，然后让这些账户给你投票就行了。或者，你还可以跟朋友们商量好，都彼此捧场也行。（例如用户 0、1 和 2 好像就是这么干的。）</p><p class="calibre_">因此，指标最好还要考虑到给你投赞同票的那些人。也就是说，来自得票数较多的人的投票的分量应该重于得票数较少的那些人的投票。这实际上就是 PageRank 算法的思想精华，Google 就是利用它来给网站排名的，主要考量的就是链接到该网站的其他站点、到达该网站的链接等。</p><p class="calibre_">（这是否让你想起了特征向量中心度背后的思想依据呢？）</p><p class="calibre_">下面是这种思想的简化版本。</p><p class="calibre_">1. 网络中 PageRank 的总分数为 1（或 100%）。</p><p class="calibre_">2. 最初，这个 PageRank 被均匀分布到网络的各个节点中。</p><p class="calibre_">3. 在每一步中，每个节点的 PageRank 很大一部分将均匀分布到其外部链接中。</p><p class="calibre_">4. 在每个步骤中，每个节点的 PageRank 的其余部分被均匀地分布到所有节点上。</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def page_rank(users, damping = 0.85, num_iters = 100):<br class="calibre12"/><br class="calibre12"/>    # 一开始均匀分布PageRank<br class="calibre12"/>    num_users = len(users)<br class="calibre12"/>    pr = { user["id"] : 1 / num_users for user in users }<br class="calibre12"/><br class="calibre12"/>    # 这是PageRank的一小部分<br class="calibre12"/>    # 每个节点进行各自的迭代<br class="calibre12"/>    base_pr = (1 - damping) / num_users<br class="calibre12"/><br class="calibre12"/>    for __ in range(num_iters):<br class="calibre12"/>        next_pr = { user["id"] : base_pr for user in users }<br class="calibre12"/>        for user in users:<br class="calibre12"/>            # 将PageRank分布到外部链接中<br class="calibre12"/>            links_pr = pr[user["id"]] * damping<br class="calibre12"/>            for endorsee in user["endorses"]:<br class="calibre12"/>                next_pr[endorsee["id"]] += links_pr / len(user["endorses"])<br class="calibre12"/>        pr = next_pr<br class="calibre12"/><br class="calibre12"/>    return pr<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">PageRank（见图 21-6）表明，用户 4（也就是 Thor）是排名最高的数据科学家。</p><p class="calibre_12"><img src="images/00087.jpg" class="calibre_153"/>
</p><p class="calibre_">
<span class="bold">图 21-6：利用 PageRank 绘制的 DataSciencester 网络</span>
</p><p class="calibre_">与用户 0、1 和 2 相比，虽然给他投票的人（2 个）并不多，但是他的得票数还要考虑投票方自身的排名。此外，两个投票方都给只给他投了票，这就意味着他不必与别人分享他们的排名。</p><div class="mbp_pagebreak" id="calibre_pb_150"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
