<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos408078" class="calibre_"><span class="calibre6"><span class="bold"> 12.2　案例：最喜欢的编程语言 </span></span></p><p class="calibre_">DataSciencester 第一次用户调查的结果回来了，我们从中找到了一系列大城市用户偏爱的编程语言：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 每一条记录都是([longitude, latitude], favorite_language)的形式<br class="calibre12"/><br class="calibre12"/>cities = [([-122.3 , 47.53], "Python"),  # 西雅图<br class="calibre12"/>          ([-96.85, 32.85], "Java"),     # 奥斯汀<br class="calibre12"/>          ([ -89.33, 43.13], "R"),       # 麦迪逊<br class="calibre12"/>          # ……还有很多记录<br class="calibre12"/>]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">社区参与部门的副总想知道我们能不能用这些结果来预测那些我们没有调查到的地方最喜欢的编程语言是什么。</p><p class="calibre_">一如既往地，第一步最好是先根据数据作图（如图 12-1 所示）：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 键是语言，值是成对数据(longitudes, latitudes)<br class="calibre12"/>plots = { "Java" : ([], []), "Python" : ([], []), "R" : ([], []) }<br class="calibre12"/><br class="calibre12"/># 我们希望每种语言都能有不同的记号和颜色<br class="calibre12"/>markers = { "Java" : "o", "Python" : "s", "R" : "^" }<br class="calibre12"/>colors  = { "Java" : "r", "Python" : "b", "R" : "g" }<br class="calibre12"/><br class="calibre12"/>for (longitude, latitude), language in cities:<br class="calibre12"/>    plots[language][0].append(longitude)<br class="calibre12"/>    plots[language][1].append(latitude)<br class="calibre12"/><br class="calibre12"/># 对每种语言创建一个散点序列<br class="calibre12"/>for language, (x, y) in plots.iteritems():<br class="calibre12"/>    plt.scatter(x, y, color=colors[language], marker=markers[language],<br class="calibre12"/>                      label=language, zorder=10)<br class="calibre12"/><br class="calibre12"/>plot_state_borders(plt)       # 假设我们有一个实现这一步的函数<br class="calibre12"/><br class="calibre12"/>plt.legend(loc=0)             # 让matplotlib选择一个位置<br class="calibre12"/>plt.axis([-130,-60,20,55])    # 设置轴<br class="calibre12"/><br class="calibre12"/>plt.title("最受欢迎的编程语言")<br class="calibre12"/>plt.show()<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_19"><img src="images/00011.jpg" class="calibre_84"/>
</p><p class="calibre_">
<span class="bold">图 12-1：最受欢迎的编程语言</span>
</p><blockquote class="calibre_32"><img src="images/00100.jpg" class="calibre_10"/>
</blockquote><blockquote class="calibre_14">你可能注意到了对 <tt class="calibre7">plot_state_borders()</tt> 的调用，这是一个没有被精确定义的函数。本书的 GitHub 页面（<a href="https://github.com/joelgrus/data-science-from-scratch" class="calibre3">https://github.com/joelgrus/data-science-from-scratch</a> ）上有这个函数的具体实现，你也可以把它当作一个练习题来自己尝试解决：</blockquote><blockquote class="calibre_14">(1) 在网络上搜索各州边界线的经纬度等信息；</blockquote><blockquote class="calibre_14">(2) 把你找到的任意经纬度数据转化为线段 [(long1, lat1), (long2, lat2)] 的列表；</blockquote><blockquote class="calibre_14">(3) 使用 <tt class="calibre7">plt.plot()</tt> 画出这些线段。</blockquote><p class="calibre_">既然互相邻近的地区看起来偏爱相同的语言，那么 <span class="italic">k</span> 近邻法作为一种预测模型看上去会是一种合理的选择。</p><p class="calibre_">首先，让我们看一下如果尝试利用邻居城市来预测每个城市偏爱的语言会得到什么结果：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/># 试试多个不同的k值<br class="calibre12"/>for k in [1, 3, 5, 7]:<br class="calibre12"/>    num_correct = 0<br class="calibre12"/><br class="calibre12"/>    for city in cities:<br class="calibre12"/>        location, actual_language = city<br class="calibre12"/>        other_cities = [other_city<br class="calibre12"/>                        for other_city in cities<br class="calibre12"/>                        if other_city != city]<br class="calibre12"/><br class="calibre12"/>        predicted_language = knn_classify(k, other_cities, location)<br class="calibre12"/><br class="calibre12"/>        if predicted_language == actual_language:<br class="calibre12"/>            num_correct += 1<br class="calibre12"/><br class="calibre12"/>     print k, "neighbor[s]:", num_correct, "correct out of", len(cities)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">看起来 3- 近邻的表现最好，59% 的时间都能给出正确结果：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>1 neighbor[s]: 40 correct out of 75<br class="calibre12"/>3 neighbor[s]: 44 correct out of 75<br class="calibre12"/>5 neighbor[s]: 41 correct out of 75<br class="calibre12"/>7 neighbor[s]: 35 correct out of 75<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">现在可以看出在每个最近邻体系下会把某个区域分类到哪种语言。我们可以在全部的网格点上进行这种分类，然后参照处理城市分类的方法把预测结果画出来：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>plots = { "Java" : ([], []), "Python" : ([], []), "R" : ([], []) }<br class="calibre12"/><br class="calibre12"/>k = 1 # 或3，或5，或……<br class="calibre12"/><br class="calibre12"/>for longitude in range(-130, -60):<br class="calibre12"/>    for latitude in range(20, 55):<br class="calibre12"/>        predicted_language = knn_classify(k, cities, [longitude, latitude])<br class="calibre12"/>        plots[predicted_language][0].append(longitude)<br class="calibre12"/>        plots[predicted_language][1].append(latitude)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">例如，图 12-2 显示了当我们只看最近的邻居（<span class="italic">k</span> =1）时会有什么结果。</p><p class="calibre_12"><img src="images/00021.jpg" class="calibre_84"/>
</p><p class="calibre_">
<span class="bold">图 12-2：1- 近邻的编程语言</span>
</p><p class="calibre_">可以看到，从一种语言到另一种语言有许多骤变，它们之间的边界也较为锐化。当我们把邻居数增加到 3 时，能看到各种语言的区域变光滑了（图 12-3）。</p><p class="calibre_12"><img src="images/00031.jpg" class="calibre_84"/>
</p><p class="calibre_">
<span class="bold">图 12-3：3- 近邻的编程语言</span>
</p><p class="calibre_">我们把邻居数增加到 5，边界变得更加光滑了（图 12-4）。</p><p class="calibre_12"><img src="images/00105.jpg" class="calibre_85"/>
</p><p class="calibre_">
<span class="bold">图 12-4：5- 近邻的编程语言</span>
</p><p class="calibre_">在这里，维度是大致可比较的，如果不是这样，你可能需要重新调整数据，就像我们在 10.4 节“数据调整”中所讲的那样。</p><div class="mbp_pagebreak" id="calibre_pb_87"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
