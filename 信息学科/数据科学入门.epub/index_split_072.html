<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos342370" class="calibre_"><span class="calibre6"><span class="bold"> 10.2　清理与修改 </span></span></p><p class="calibre_">真实世界的数据是<span class="bold">有很多问题</span> 的。在使用数据之前，你通常需要对它们进行一定的预处理。我们在第 9 章举过这样的例子。我们需要把字符串转化成可以使用的浮点型数据（<tt class="calibre7">float</tt> ）或者整型数据（<tt class="calibre7">int</tt> ）。以前，我们在使用数据之前会这样做：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>closing_price = float(row[2])<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">但通过建立包括 <tt class="calibre7">csv.reader</tt> 的函数，这样进行解析更不容易触发误差。我们会列出一系列解析器，每个解析器具体说明其中一列如何解析。我们会用 <tt class="calibre7">None</tt> 表示“对这列什么都不做”：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def parse_row(input_row, parsers):<br class="calibre12"/>    """given a list of parsers (some of which may be None)<br class="calibre12"/>    apply the appropriate one to each element of the input_row"""<br class="calibre12"/><br class="calibre12"/>    return [parser(value) if parser is not None else value<br class="calibre12"/>            for value, parser in zip(input_row, parsers)]<br class="calibre12"/><br class="calibre12"/>def parse_rows_with(reader, parsers):<br class="calibre12"/>    """wrap a reader to apply the parsers to each of its rows"""<br class="calibre12"/>    for row in reader:<br class="calibre12"/>        yield parse_row(row, parsers)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">如果有不良数据怎么办？一个浮点值是否真正代表一个数字？我们通常会使用一个 <tt class="calibre7">None</tt> 函数而非硬跑程序。我们可以通过一个辅助函数来解决：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def try_or_none(f):<br class="calibre12"/>    """wraps f to return None if f raises an exception<br class="calibre12"/>    assumes f takes only one input"""<br class="calibre12"/>    def f_or_none(x):<br class="calibre12"/>        try: return f(x)<br class="calibre12"/>        except: return None<br class="calibre12"/>    return f_or_none<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">然后我们重写 <tt class="calibre7">parse_row</tt> 来使用它：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def parse_row(input_row, parsers):<br class="calibre12"/>    return [try_or_none(parser)(value) if parser is not None else value<br class="calibre12"/>            for value, parser in zip(input_row, parsers)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">比如，如果我们用逗号分割的股票数据中有不良数据：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>6/20/2014,AAPL,90.91<br class="calibre12"/>6/20/2014,MSFT,41.68<br class="calibre12"/>6/20/3014,FB,64.5<br class="calibre12"/>6/19/2014,AAPL,91.86<br class="calibre12"/>6/19/2014,MSFT,n/a<br class="calibre12"/>6/19/2014,FB,64.34<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们现在可以在一个单独步骤中读入和解析：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import dateutil.parser<br class="calibre12"/>data = []<br class="calibre12"/><br class="calibre12"/>with open("comma_delimited_stock_prices.csv", "rb") as f:<br class="calibre12"/>    reader = csv.reader(f)<br class="calibre12"/>    for line in parse_rows_with(reader, [dateutil.parser.parse, None, float]):<br class="calibre12"/>        data.append(line)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">然后我们只需检查其中 <tt class="calibre7">None</tt> 的行数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>for row in data:<br class="calibre12"/>    if any(x is None for x in row):<br class="calibre12"/>        print row<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">然后再决定如何处理它们。（一般来说，你有三个选择：删除它们；溯源并修复不良数据或缺失数据；什么都不做，自求多福吧。）</p><p class="calibre_">我们可以为 <tt class="calibre7">csv.DictReader</tt> 创建相似的帮助函数。这样的话，你很可能希望提供基于域名的解析字典。例如：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def try_parse_field(field_name, value, parser_dict):<br class="calibre12"/>    """try to parse value using the appropriate function from parser_dict"""<br class="calibre12"/>    parser = parser_dict.get(field_name)   # 如果没有此条目，则为None<br class="calibre12"/>    if parser is not None:<br class="calibre12"/>        return try_or_none(parser)(value)<br class="calibre12"/>    else:<br class="calibre12"/>        return value<br class="calibre12"/><br class="calibre12"/>def parse_dict(input_dict, parser_dict):<br class="calibre12"/>    return { field_name : try_parse_field(field_name, value, parser_dict)<br class="calibre12"/>             for field_name, value in input_dict.iteritems() }<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">接下来最好是使用 10.1 节所讲的技术或即时分析来确认异常值。比如，如果你发现股票文件中有一个数据的时间是 3014 年，这不会给你报错提示，但这显然是错误的数据。如果你没有发现这个错误，就会得到很糟糕的结果。真实世界的数据集充斥着诸如小数点缺失、多余的零、排印错误等无数各种各样的错误，找出错误是你责无旁贷的工作。（也许这不是你的正式工作，但这工作又非你做不可。）</p><div class="mbp_pagebreak" id="calibre_pb_72"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
