<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos714333" class="calibre_"><span class="calibre6"><span class="bold"> 23.5　</span></span><span class="calibre6"><tt class="calibre7"><span class="bold">GROUP BY</span></tt></span><span class="calibre6"><span class="bold">  </span></span></p><p class="calibre_">另一种常见的 SQL 操作是 <tt class="calibre7">GROUP BY</tt> ，它可以将在特定列有相同值的行进行分组，并求出特定的汇总值，如 <tt class="calibre7">MIN</tt> 、<tt class="calibre7">MAX</tt> 、<tt class="calibre7">COUNT</tt> 或 <tt class="calibre7">SUM</tt> 。（回想 10.3 节“处理数据”中提到的 <tt class="calibre7">group_by</tt> 函数。）</p><p class="calibre_">例如，你需要对每个可能的名字长度找出相应的用户数目和最小 <tt class="calibre7">user_id</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>SELECT LENGTH(name) as name_length,<br class="calibre12"/> MIN(user_id) AS min_user_id,<br class="calibre12"/> COUNT(*) AS num_users<br class="calibre12"/>FROM users<br class="calibre12"/>GROUP BY LENGTH(name);<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们通过 <tt class="calibre7">SELECT</tt> 生成的每个字段，要么需要在 <tt class="calibre7">GROUP BY</tt> 语句中完成（<tt class="calibre7">name_length</tt> 就是这样），要么需要汇总计算（<tt class="calibre7">min_user_id</tt> 和 <tt class="calibre7">num_users</tt> 就是这样）。</p><p class="calibre_">SQL 同样支持 <tt class="calibre7">HAVING</tt> 子句，它和 <tt class="calibre7">WHERE</tt> 子句类似，只是前者只对汇总结果过滤（而后者在汇总计算之前就过滤）。</p><p class="calibre_">也许你想知道名字以某些特定字母开头的用户的平均朋友数，结果却只看到了平均个数大于 1 的结果。（是的，其中某些例子是人为的。）</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>SELECT SUBSTR(name, 1, 1) AS first_letter,<br class="calibre12"/> AVG(num_friends) AS avg_num_friends<br class="calibre12"/>FROM users<br class="calibre12"/>GROUP BY SUBSTR(name, 1, 1)<br class="calibre12"/>HAVING AVG(num_friends) &gt; 1;<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">（处理字符串的函数会基于不同的 SQL 实现而有所不同；一些数据库会用 <tt class="calibre7">SUBSTRING</tt> 或者别的方式。）</p><p class="calibre_">你也可以计算总体的汇总值，这时我们不用 <tt class="calibre7">GROUP BY</tt> ：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>SELECT SUM(user_id) as user_id_sum<br class="calibre12"/>FROM users<br class="calibre12"/>WHERE user_id &gt; 1;<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">为了对 NotQuiteABase 表增加这项函数功能，我们增加一个 <tt class="calibre7">group_by()</tt> 方法。它首先取你希望分组的列名、你希望对每组运行的汇总函数的字典和作用于多行的可选判定函数 <tt class="calibre7">having</tt> 。</p><p class="calibre_">然后完成以下步骤。</p><p class="calibre_">1. 生成默认字典，将（按值分组的）元组映射到行（包含按值分的组）。前面提过，列表不可以用作字典的键；你得使用元组。</p><p class="calibre_">2. 遍历表的每一行，填充 <tt class="calibre7">defaultdict</tt> 。</p><p class="calibre_">3. 用正确的输出列生成新表。</p><p class="calibre_">4. 遍历 <tt class="calibre7">defaultdict</tt> ，并填充输出表。使用 <tt class="calibre7">having</tt> 过滤（如果有的话）。</p><p class="calibre_">（实际的数据库会用更有效的方式完成这些步骤。）</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def group_by(self, group_by_columns, aggregates, having=None):<br class="calibre12"/><br class="calibre12"/>    grouped_rows = defaultdict(list)<br class="calibre12"/><br class="calibre12"/>    # 填充组<br class="calibre12"/>    for row in self.rows:<br class="calibre12"/>        key = tuple(row[column] for column in group_by_columns)<br class="calibre12"/>        grouped_rows[key].append(row)<br class="calibre12"/><br class="calibre12"/>    # 结果表中包含组列与汇总<br class="calibre12"/>    result_table = Table(group_by_columns + aggregates.keys())<br class="calibre12"/><br class="calibre12"/>    for key, rows in grouped_rows.iteritems():<br class="calibre12"/>        if having is None or having(rows):<br class="calibre12"/>            new_row = list(key)<br class="calibre12"/>            for aggregate_name, aggregate_fn in aggregates.iteritems():<br class="calibre12"/>                new_row.append(aggregate_fn(rows))<br class="calibre12"/>            result_table.insert(new_row)<br class="calibre12"/><br class="calibre12"/>    return result_table<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们再来看看为了完成先前 SQL 语句的功能还能用什么别的方法。<tt class="calibre7">name_length</tt> 标准表示如下所示：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def min_user_id(rows): return min(row["user_id"] for row in rows)<br class="calibre12"/>stats_by_length = users \<br class="calibre12"/>    .select(additional_columns={"name_length" : name_length}) \<br class="calibre12"/>    .group_by(group_by_columns=["name_length"],<br class="calibre12"/>              aggregates={ "min_user_id" : min_user_id,<br class="calibre12"/>                           "num_users" : len })<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">
<tt class="calibre7">first_letter</tt> 的标准表示是：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def first_letter_of_name(row):<br class="calibre12"/>    return row["name"][0] if row["name"] else ""<br class="calibre12"/><br class="calibre12"/>def average_num_friends(rows):<br class="calibre12"/>    return sum(row["num_friends"] for row in rows) / len(rows)<br class="calibre12"/><br class="calibre12"/>def enough_friends(rows):<br class="calibre12"/>    return average_num_friends(rows) &gt; 1<br class="calibre12"/><br class="calibre12"/>avg_friends_by_letter = users \<br class="calibre12"/>    .select(additional_columns={'first_letter' : first_letter_of_name}) \<br class="calibre12"/>    .group_by(group_by_columns=['first_letter'],<br class="calibre12"/>              aggregates={ "avg_num_friends" : average_num_friends },<br class="calibre12"/>              having=enough_friends)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">
<tt class="calibre7">user_id_sum</tt> 的标准表示是：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def sum_user_ids(rows): return sum(row["user_id"] for row in rows)<br class="calibre12"/><br class="calibre12"/>user_id_sum = users \<br class="calibre12"/>    .where(lambda row: row["user_id"] &gt; 1) \<br class="calibre12"/>    .group_by(group_by_columns=[],<br class="calibre12"/>              aggregates={ "user_id_sum" : sum_user_ids })<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><div class="mbp_pagebreak" id="calibre_pb_163"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
