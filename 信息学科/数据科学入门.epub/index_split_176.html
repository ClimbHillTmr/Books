<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos751676" class="calibre_15"><span class="calibre6"><span class="bold"> 24.5　案例：矩阵计算 </span></span></p><p class="calibre_">回想 22.2.1 节“矩阵乘法”，给定一个 <span class="italic">m</span> × <span class="italic">n</span> 的矩阵 <span class="italic">A</span> 和一个 <span class="italic">n</span> × <span class="italic">k</span> 的矩阵 <span class="italic">B</span> ，可以把它们乘起来得到 <span class="italic">m</span> × <span class="italic">k</span> 的矩阵 <span class="italic">C</span> ，其中 <span class="italic">C</span> 的第 <span class="italic">i</span> 行第 <span class="italic">j</span> 列的元素由下式给出：</p><p class="calibre_12"><img src="images/00090.jpg" class="calibre_154"/>
</p><p class="calibre_">如同我们之前所见的，表示一个 <span class="italic">m</span> × <span class="italic">n</span> 矩阵的“自然的”方法是列表的列表，其中元素 <span class="italic">A<sub class="calibre17"><small class="calibre9"><span class="calibre18"><span class="italic">ij</span></span></small></sub>
</span> 是第 <span class="italic">i</span> 个列表的第 <span class="italic">j</span> 个元素。</p><p class="calibre_">但大型矩阵有时候是<span class="bold">稀疏</span> 的，即大部分的元素等于 0。对于大型稀疏矩阵而言，列表的列表是一种非常浪费的表达方式。一种更简洁的表达方式是元组的列表 <tt class="calibre7">(name, i, j, value)</tt> ，其中 <tt class="calibre7">name</tt> 代表矩阵，而 <tt class="calibre7">i</tt> 、<tt class="calibre7">j</tt> 、<tt class="calibre7">value</tt> 表示一个非零元素的位置。</p><p class="calibre_">比如，一个十亿 × 十亿的矩阵会有亿亿级别（quintillion，1×10<sup class="calibre19"><small class="calibre9"><span class="calibre18">18</span></small></sup> ）的元素，这是难以存储在一个计算机中的。但是如果每行当中只有不多的一些非零元素，上面那种替代的表示法就会小很多个数量级。</p><p class="calibre_">基于这种表示法，我们可以使用 MapReduce 以分布式的方式执行矩阵乘法。</p><p class="calibre_">为使用这种算法，请注意，<span class="italic">A<sub class="calibre17"><small class="calibre9"><span class="calibre18"><span class="italic">ij</span></span></small></sub>
</span> 只用于计算 <span class="italic">C</span> 的第 <span class="italic">i</span> 行的元素，<span class="italic">B<sub class="calibre17"><small class="calibre9"><span class="calibre18"><span class="italic">ij</span></span></small></sub>
</span> 只用于计算 <span class="italic">C</span> 的第 <span class="italic">j</span> 列的元素。我们的目标是使 <tt class="calibre7">reducer</tt> 的每一个输出构成矩阵 <span class="italic">C</span> 的一个元素。这意味着我们需要用 <tt class="calibre7">mapper</tt> 发送键值，以确定 <span class="italic">C</span> 中的每个元素。建议像下面这样处理：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>def matrix_multiply_mapper(m, element):<br class="calibre12"/>    """m is the common dimension (columns of A, rows of B)<br class="calibre12"/>    element is a tuple (matrix_name, i, j, value)"""<br class="calibre12"/>    name, i, j, value = element<br class="calibre12"/><br class="calibre12"/>    if name == "A":<br class="calibre12"/>        # A_ij是每个C_ik之和的第j个元素，其中k=1..m<br class="calibre12"/>        for k in range(m):<br class="calibre12"/>            # 与C_ik的其他元素分组<br class="calibre12"/>            yield((i, k), (j, value))<br class="calibre12"/>    else:<br class="calibre12"/>        # B_ij是每个C_kj之和的第i个元素<br class="calibre12"/>        for k in range(m):<br class="calibre12"/>            # 与C_kj的其他元素分组<br class="calibre12"/>            yield((k, j), (i, value))<br class="calibre12"/><br class="calibre12"/>def matrix_multiply_reducer(m, key, indexed_values):<br class="calibre12"/>    results_by_index = defaultdict(list)<br class="calibre12"/>    for index, value in indexed_values:<br class="calibre12"/>        results_by_index[index].append(value)<br class="calibre12"/><br class="calibre12"/>    # 对有两个结果的位置把所有的乘积加起来<br class="calibre12"/>    sum_product = sum(results[0] * results[1]<br class="calibre12"/>                      for results in results_by_index.values()<br class="calibre12"/>                      if len(results) == 2)<br class="calibre12"/><br class="calibre12"/>    if sum_product != 0.0:<br class="calibre12"/>        yield (key, sum_product)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">比如，如果你有如下的两个矩阵：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>A = [[3, 2, 0],<br class="calibre12"/>     [0, 0, 0]]<br class="calibre12"/><br class="calibre12"/>B = [[4, -1, 0],<br class="calibre12"/>     [10, 0, 0],<br class="calibre12"/>     [0, 0, 0]]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">你可以把它们重写为元组：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>entries = [("A", 0, 0, 3), ("A", 0, 1,  2),<br class="calibre12"/>           ("B", 0, 0, 4), ("B", 0, 1, -1), ("B", 1, 0, 10)]<br class="calibre12"/>mapper = partial(matrix_multiply_mapper, 3)<br class="calibre12"/>reducer = partial(matrix_multiply_reducer, 3)<br class="calibre12"/><br class="calibre12"/>map_reduce(entries, mapper, reducer) # [((0, 1), -3), ((0, 0), 32)]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">在这样一个小矩阵上操作并不太有趣，但是如果你有百万行百万列的矩阵，MapReduce 就会起很大作用。</p><div class="mbp_pagebreak" id="calibre_pb_176"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
