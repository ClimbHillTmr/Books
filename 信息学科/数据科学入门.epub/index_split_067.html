<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>数据科学入门</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos314371" class="calibre_"><span class="calibre6"><span class="bold"> 9.4　使用API </span></span></p><p class="calibre_">许多网站和网络服务提供相应的应用程序接口（Application Programming Interface，API），允许你明确地请求结构化格式的数据。这省去了你不得不抓取数据的麻烦！</p><p id="filepos314688" class="calibre_"><span class="calibre6"><span class="bold"> 9.4.1　JSON（和XML） </span></span></p><p class="calibre_">因为 HTTP 是一种转换<span class="bold">文本</span> 的协议，你通过网络 API 请求的数据需要<span class="bold">串行化</span> （serialized）地转换为字符串格式。通常这种串行化使用 JavaScript 对象符号（JavaScript Object Notation，JSON）。JavaScript 对象看起来和 Python 的字典很像，使得字符串表达非常容易解释：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>{ "title" : "Data Science Book",<br class="calibre12"/>  "author" : "Joel Grus",<br class="calibre12"/>  "publicationYear" : 2014,<br class="calibre12"/>  "topics" : [ "data", "science", "data science"] }<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们可以使用 Python 的 <tt class="calibre7">json</tt> 模块来解析 JSON。尤其是，我们会用到它的 <tt class="calibre7">loads</tt> 函数，这个函数可以把一个代表 JSON 对象的字符串<span class="bold">反串行化</span> （deserialize）为 Python 对象：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import json<br class="calibre12"/>serialized = """{ "title" : "Data Science Book",<br class="calibre12"/>                  "author" : "Joel Grus",<br class="calibre12"/>                  "publicationYear" : 2014,<br class="calibre12"/>                  "topics" : [ "data", "science", "data science"] }"""<br class="calibre12"/><br class="calibre12"/># 解析JSON以创建一个Python字典<br class="calibre12"/>deserialized = json.loads(serialized)<br class="calibre12"/>if "data science" in deserialized["topics"]:<br class="calibre12"/>    print deserialized<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">有时候 API 的提供者可能会不耐烦，只给你提供 XML 格式的响应：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>&lt;Book&gt;<br class="calibre12"/>  &lt;Title&gt;Data Science Book&lt;/Title&gt;<br class="calibre12"/>  &lt;Author&gt;Joel Grus&lt;/Author&gt;<br class="calibre12"/>  &lt;PublicationYear&gt;2014&lt;/PublicationYear&gt;<br class="calibre12"/>  &lt;Topics&gt;<br class="calibre12"/>    &lt;Topic&gt;data&lt;/Topic&gt;<br class="calibre12"/>    &lt;Topic&gt;science&lt;/Topic&gt;<br class="calibre12"/>    &lt;Topic&gt;data science&lt;/Topic&gt;<br class="calibre12"/>  &lt;/Topics&gt;<br class="calibre12"/>&lt;/Book&gt;<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">我们也可以仿照从 HTML 获取数据的方式，用 <tt class="calibre7">BeautifulSoup</tt> 从 XML 中获取数据；更多细节可查阅文档。</p><p id="filepos317216" class="calibre_"><span class="calibre6"><span class="bold"> 9.4.2　使用无验证的API </span></span></p><p class="calibre_">现在大多数的 API 要求你在使用之前先验证身份。而若我们不愿勉强自己屈就这种政策，API 会给出许多其他的陈词滥调来阻止我们的浏览。因此，先来看一下 GitHub 的 API（<a href="https://developer.github.com/v3/" class="calibre3">https://developer.github.com/v3/</a> ），利用它我们可以做一些简单的无需验证的事情：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>import requests, json<br class="calibre12"/>endpoint = "https://api.github.com/users/joelgrus/repos"<br class="calibre12"/><br class="calibre12"/>repos = json.loads(requests.get(endpoint).text)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">此处 <tt class="calibre7">repos</tt> 是一个 Python 字典的列表，其中每一个字典表示我的 GitHub 账户的一个代码仓库。（可以随意替换成你的用户名，以取得你的代码仓库的数据。你有 GitHub 账号，对吧？）</p><p class="calibre_">这个结果能指出哪个月哪一周的哪一天我最愿意创建代码仓库。唯一的问题是，响应里的日期是（Unicode）字符串：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>u'created_at': u'2013-07-05T02:02:28Z'<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">Python 本身没有很强大的日期解析器，所以我们需要安装一个：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>pip install python-dateutil<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">其中你需要的可能只是 <tt class="calibre7">dateutil.parser.parse</tt> 函数：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>from dateutil.parser import parse<br class="calibre12"/><br class="calibre12"/>dates = [parse(repo["created_at"]) for repo in repos]<br class="calibre12"/>month_counts = Counter(date.month for date in dates)<br class="calibre12"/>weekday_counts = Counter(date.weekday() for date in dates)<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">类似地，你可以获取我最后五个代码仓库所用的语言：</p><blockquote class="calibre_14"><span class="calibre11"><tt class="calibre7"><br class="calibre12"/>last_5_repositories = sorted(repos,<br class="calibre12"/>                             key=lambda r: r["created_at"],<br class="calibre12"/>                             reverse=True)[:5]<br class="calibre12"/><br class="calibre12"/>last_5_languages = [repo["language"]<br class="calibre12"/>                    for repo in last_5_repositories]<br class="calibre12"/><br class="calibre12"/><br class="calibre12"/><br class="calibre12"/></tt></span></blockquote><p class="calibre_15">通常我们无需在“做出请求而且自己解析响应”这种低层次上使用 API。使用 Python 的好处之一是已经有人建好了库，方便你访问你感兴趣的几乎所有 API。这些库可以把事情做好，为你省下查找 API 访问的诸多冗长细节的麻烦。（如果这些库不能很好地完成任务，或者它们依赖的是对应的 API 已失效的版本，那就会给你带来巨大的麻烦。）</p><p class="calibre_">尽管如此，偶尔你还是需要操作你自己的 API 访问库（或者，更常见的，去调试别人不能顺利操作的库），所以了解一些细节是很有好处的。</p><p id="filepos320657" class="calibre_"><span class="calibre6"><span class="bold"> 9.4.3　寻找API </span></span></p><p class="calibre_">如果你需要一个特定网站的数据，可以查看它的开发者部分或 API 部分的细节，然后以关键词“python api”在网络上搜索相应的库。Python 有一个 Rotten Tomatoes 的库。Python 还有针对 Klout、Yelp、IMDB 等的多个 API 封装。</p><p class="calibre_">如果你想查看有 Python 封装的 API 列表，可参阅 Python API（<a href="http://www.pythonapi.com/" class="calibre3">http://www.pythonapi.com/</a> ）和 Python for Beginners（<a href="http://www.pythonforbeginners.com/development/list-of-python-apis/" class="calibre3">http://www.pythonforbeginners.com/development/list-of-python-apis/</a> ）中的两个名录。</p><p class="calibre_">如果你想要的是一份更宽泛的网络 API 名录（不一定含有 Python 封装），Programmable Web（<a href="http://www.programmableweb.com/" class="calibre3">http://www.programmableweb.com/</a> ）是个好的资源，它有一个关于分好类的 API 的庞大名录。</p><p class="calibre_">如果最终还是找不到你需要的 API，还是可以通过抓取获得的。这是数据科学家最后的绝招。</p><div class="mbp_pagebreak" id="calibre_pb_67"></div>
<div class="calibre5">本书由「<a href="https://epubw.com" class="calibre3">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre3">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</div></body></html>
