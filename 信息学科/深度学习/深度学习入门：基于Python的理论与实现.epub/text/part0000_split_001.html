<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles1.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="calibre1"><a href="part0000_split_002.html#nav_point_0" class="calibre5">版权声明</a></p><p class="calibre1"><a href="part0000_split_003.html#nav_point_1" class="calibre5">O'Reilly Media, Inc.介绍</a></p><p class="calibre1"><a href="part0000_split_004.html#nav_point_2" class="calibre5">业界评论</a></p><p class="calibre1"><a href="part0000_split_005.html#nav_point_3" class="calibre5">译者序</a></p><p class="calibre1"><a href="part0000_split_006.html#nav_point_4" class="calibre5">前言</a></p><p class="calibre1"><a href="part0000_split_007.html#nav_point_5" class="calibre5">本书的理念</a></p><p class="calibre1"><a href="part0000_split_008.html#nav_point_6" class="calibre5">本书面向的读者</a></p><p class="calibre1"><a href="part0000_split_009.html#nav_point_7" class="calibre5">本书不面向的读者</a></p><p class="calibre1"><a href="part0000_split_010.html#nav_point_8" class="calibre5">本书的阅读方法</a></p><p class="calibre1"><a href="part0000_split_011.html#nav_point_9" class="calibre5">让我们开始吧</a></p><p class="calibre1"><a href="part0000_split_012.html#nav_point_10" class="calibre5">表述规则</a></p><p class="calibre1"><a href="part0000_split_013.html#nav_point_11" class="calibre5">致谢</a></p><p class="calibre1"><a href="part0000_split_014.html#nav_point_12" class="calibre5">第 1 章　Python 入门</a></p><p class="calibre1"><a href="part0000_split_015.html#nav_point_13" class="calibre5">1.1　Python是什么</a></p><p class="calibre1"><a href="part0000_split_016.html#nav_point_14" class="calibre5">1.2　Python的安装</a></p><p class="calibre1"><a href="part0000_split_016.html#nav_point_15" class="calibre5">1.2.1　Python版本</a></p><p class="calibre1"><a href="part0000_split_016.html#nav_point_16" class="calibre5">1.2.2　使用的外部库</a></p><p class="calibre1"><a href="part0000_split_016.html#nav_point_17" class="calibre5">1.2.3　Anaconda发行版</a></p><p class="calibre1"><a href="part0000_split_017.html#nav_point_18" class="calibre5">1.3　Python解释器</a></p><p class="calibre1"><a href="part0000_split_017.html#nav_point_19" class="calibre5">1.3.1　算术计算</a></p><p class="calibre1"><a href="part0000_split_017.html#nav_point_20" class="calibre5">1.3.2　数据类型</a></p><p class="calibre1"><a href="part0000_split_017.html#nav_point_21" class="calibre5">1.3.3　变量</a></p><p class="calibre1"><a href="part0000_split_017.html#nav_point_22" class="calibre5">1.3.4　列表</a></p><p class="calibre1"><a href="part0000_split_017.html#nav_point_23" class="calibre5">1.3.5　字典</a></p><p class="calibre1"><a href="part0000_split_017.html#nav_point_24" class="calibre5">1.3.6　布尔型</a></p><p class="calibre1"><a href="part0000_split_017.html#nav_point_25" class="calibre5">1.3.7　if 语句</a></p><p class="calibre1"><a href="part0000_split_017.html#nav_point_26" class="calibre5">1.3.8　for 语句</a></p><p class="calibre1"><a href="part0000_split_017.html#nav_point_27" class="calibre5">1.3.9　函数</a></p><p class="calibre1"><a href="part0000_split_018.html#nav_point_28" class="calibre5">1.4　Python脚本文件</a></p><p class="calibre1"><a href="part0000_split_018.html#nav_point_29" class="calibre5">1.4.1　保存为文件</a></p><p class="calibre1"><a href="part0000_split_018.html#nav_point_30" class="calibre5">1.4.2　类</a></p><p class="calibre1"><a href="part0000_split_019.html#nav_point_31" class="calibre5">1.5　NumPy</a></p><p class="calibre1"><a href="part0000_split_019.html#nav_point_32" class="calibre5">1.5.1　导入 NumPy</a></p><p class="calibre1"><a href="part0000_split_019.html#nav_point_33" class="calibre5">1.5.2　生成 NumPy 数组</a></p><p class="calibre1"><a href="part0000_split_019.html#nav_point_34" class="calibre5">1.5.3　NumPy 的算术运算</a></p><p class="calibre1"><a href="part0000_split_019.html#nav_point_35" class="calibre5">1.5.4　NumPy 的 N 维数组</a></p><p class="calibre1"><a href="part0000_split_019.html#nav_point_36" class="calibre5">1.5.5　广播</a></p><p class="calibre1"><a href="part0000_split_019.html#nav_point_37" class="calibre5">1.5.6　访问元素</a></p><p class="calibre1"><a href="part0000_split_020.html#nav_point_38" class="calibre5">1.6　Matplotlib</a></p><p class="calibre1"><a href="part0000_split_020.html#nav_point_39" class="calibre5">1.6.1　绘制简单图形</a></p><p class="calibre1"><a href="part0000_split_020.html#nav_point_40" class="calibre5">1.6.2　pyplot 的功能</a></p><p class="calibre1"><a href="part0000_split_020.html#nav_point_41" class="calibre5">1.6.3　显示图像</a></p><p class="calibre1"><a href="part0000_split_021.html#nav_point_42" class="calibre5">1.7　小结</a></p><p class="calibre1"><a href="part0000_split_022.html#nav_point_43" class="calibre5">第 2 章　感知机</a></p><p class="calibre1"><a href="part0000_split_023.html#nav_point_44" class="calibre5">2.1　感知机是什么</a></p><p class="calibre1"><a href="part0000_split_024.html#nav_point_45" class="calibre5">2.2　简单逻辑电路</a></p><p class="calibre1"><a href="part0000_split_024.html#nav_point_46" class="calibre5">2.2.1　与门</a></p><p class="calibre1"><a href="part0000_split_024.html#nav_point_47" class="calibre5">2.2.2　与非门和或门</a></p><p class="calibre1"><a href="part0000_split_025.html#nav_point_48" class="calibre5">2.3　感知机的实现</a></p><p class="calibre1"><a href="part0000_split_025.html#nav_point_49" class="calibre5">2.3.1　简单的实现</a></p><p class="calibre1"><a href="part0000_split_025.html#nav_point_50" class="calibre5">2.3.2　导入权重和偏置</a></p><p class="calibre1"><a href="part0000_split_025.html#nav_point_51" class="calibre5">2.3.3　使用权重和偏置的实现</a></p><p class="calibre1"><a href="part0000_split_026.html#nav_point_52" class="calibre5">2.4　感知机的局限性</a></p><p class="calibre1"><a href="part0000_split_026.html#nav_point_53" class="calibre5">2.4.1　异或门</a></p><p class="calibre1"><a href="part0000_split_026.html#nav_point_54" class="calibre5">2.4.2　线性和非线性</a></p><p class="calibre1"><a href="part0000_split_027.html#nav_point_55" class="calibre5">2.5　多层感知机</a></p><p class="calibre1"><a href="part0000_split_027.html#nav_point_56" class="calibre5">2.5.1　已有门电路的组合</a></p><p class="calibre1"><a href="part0000_split_027.html#nav_point_57" class="calibre5">2.5.2　异或门的实现</a></p><p class="calibre1"><a href="part0000_split_028.html#nav_point_58" class="calibre5">2.6　从与非门到计算机</a></p><p class="calibre1"><a href="part0000_split_029.html#nav_point_59" class="calibre5">2.7　小结</a></p><p class="calibre1"><a href="part0000_split_030.html#nav_point_60" class="calibre5">第 3 章　神经网络</a></p><p class="calibre1"><a href="part0000_split_031.html#nav_point_61" class="calibre5">3.1　从感知机到神经网络</a></p><p class="calibre1"><a href="part0000_split_031.html#nav_point_62" class="calibre5">3.1.1　神经网络的例子</a></p><p class="calibre1"><a href="part0000_split_031.html#nav_point_63" class="calibre5">3.1.2　复习感知机</a></p><p class="calibre1"><a href="part0000_split_031.html#nav_point_64" class="calibre5">3.1.3　激活函数登场</a></p><p class="calibre1"><a href="part0000_split_032.html#nav_point_65" class="calibre5">3.2　激活函数</a></p><p class="calibre1"><a href="part0000_split_032.html#nav_point_66" class="calibre5">3.2.1　sigmoid 函数</a></p><p class="calibre1"><a href="part0000_split_032.html#nav_point_67" class="calibre5">3.2.2　阶跃函数的实现</a></p><p class="calibre1"><a href="part0000_split_032.html#nav_point_68" class="calibre5">3.2.3　阶跃函数的图形</a></p><p class="calibre1"><a href="part0000_split_032.html#nav_point_69" class="calibre5">3.2.4　sigmoid 函数的实现</a></p><p class="calibre1"><a href="part0000_split_032.html#nav_point_70" class="calibre5">3.2.5　sigmoid 函数和阶跃函数的比较</a></p><p class="calibre1"><a href="part0000_split_032.html#nav_point_71" class="calibre5">3.2.6　非线性函数</a></p><p class="calibre1"><a href="part0000_split_032.html#nav_point_72" class="calibre5">3.2.7　ReLU函数</a></p><p class="calibre1"><a href="part0000_split_033.html#nav_point_73" class="calibre5">3.3　多维数组的运算</a></p><p class="calibre1"><a href="part0000_split_033.html#nav_point_74" class="calibre5">3.3.1　多维数组</a></p><p class="calibre1"><a href="part0000_split_033.html#nav_point_75" class="calibre5">3.3.2　矩阵乘法</a></p><p class="calibre1"><a href="part0000_split_033.html#nav_point_76" class="calibre5">3.3.3　神经网络的内积</a></p><p class="calibre1"><a href="part0000_split_034.html#nav_point_77" class="calibre5">3.4　3 层神经网络的实现</a></p><p class="calibre1"><a href="part0000_split_034.html#nav_point_78" class="calibre5">3.4.1　符号确认</a></p><p class="calibre1"><a href="part0000_split_034.html#nav_point_79" class="calibre5">3.4.2　各层间信号传递的实现</a></p><p class="calibre1"><a href="part0000_split_034.html#nav_point_80" class="calibre5">3.4.3　代码实现小结</a></p><p class="calibre1"><a href="part0000_split_035.html#nav_point_81" class="calibre5">3.5　输出层的设计</a></p><p class="calibre1"><a href="part0000_split_035.html#nav_point_82" class="calibre5">3.5.1　恒等函数和 softmax 函数</a></p><p class="calibre1"><a href="part0000_split_035.html#nav_point_83" class="calibre5">3.5.2　实现 softmax 函数时的注意事项</a></p><p class="calibre1"><a href="part0000_split_035.html#nav_point_84" class="calibre5">3.5.3　softmax 函数的特征</a></p><p class="calibre1"><a href="part0000_split_035.html#nav_point_85" class="calibre5">3.5.4　输出层的神经元数量</a></p><p class="calibre1"><a href="part0000_split_036.html#nav_point_86" class="calibre5">3.6　手写数字识别</a></p><p class="calibre1"><a href="part0000_split_036.html#nav_point_87" class="calibre5">3.6.1　MNIST 数据集</a></p><p class="calibre1"><a href="part0000_split_036.html#nav_point_88" class="calibre5">3.6.2　神经网络的推理处理</a></p><p class="calibre1"><a href="part0000_split_036.html#nav_point_89" class="calibre5">3.6.3　批处理</a></p><p class="calibre1"><a href="part0000_split_037.html#nav_point_90" class="calibre5">3.7　小结</a></p><p class="calibre1"><a href="part0000_split_038.html#nav_point_91" class="calibre5">第 4 章　神经网络的学习</a></p><p class="calibre1"><a href="part0000_split_039.html#nav_point_92" class="calibre5">4.1　从数据中学习</a></p><p class="calibre1"><a href="part0000_split_039.html#nav_point_93" class="calibre5">4.1.1　数据驱动</a></p><p class="calibre1"><a href="part0000_split_039.html#nav_point_94" class="calibre5">4.1.2　训练数据和测试数据</a></p><p class="calibre1"><a href="part0000_split_040.html#nav_point_95" class="calibre5">4.2　损失函数</a></p><p class="calibre1"><a href="part0000_split_040.html#nav_point_96" class="calibre5">4.2.1　均方误差</a></p><p class="calibre1"><a href="part0000_split_040.html#nav_point_97" class="calibre5">4.2.2　交叉熵误差</a></p><p class="calibre1"><a href="part0000_split_040.html#nav_point_98" class="calibre5">4.2.3　mini-batch 学习</a></p><p class="calibre1"><a href="part0000_split_040.html#nav_point_99" class="calibre5">4.2.4　mini-batch 版交叉熵误差的实现</a></p><p class="calibre1"><a href="part0000_split_040.html#nav_point_100" class="calibre5">4.2.5　为何要设定损失函数</a></p><p class="calibre1"><a href="part0000_split_041.html#nav_point_101" class="calibre5">4.3　数值微分</a></p><p class="calibre1"><a href="part0000_split_041.html#nav_point_102" class="calibre5">4.3.1　导数</a></p><p class="calibre1"><a href="part0000_split_041.html#nav_point_103" class="calibre5">4.3.2　数值微分的例子</a></p><p class="calibre1"><a href="part0000_split_041.html#nav_point_104" class="calibre5">4.3.3　偏导数</a></p><p class="calibre1"><a href="part0000_split_042.html#nav_point_105" class="calibre5">4.4　梯度</a></p><p class="calibre1"><a href="part0000_split_042.html#nav_point_106" class="calibre5">4.4.1　梯度法</a></p><p class="calibre1"><a href="part0000_split_042.html#nav_point_107" class="calibre5">4.4.2　神经网络的梯度</a></p><p class="calibre1"><a href="part0000_split_043.html#nav_point_108" class="calibre5">4.5　学习算法的实现</a></p><p class="calibre1"><a href="part0000_split_043.html#nav_point_109" class="calibre5">4.5.1　2 层神经网络的类</a></p><p class="calibre1"><a href="part0000_split_051.html#nav_point_110" class="calibre5">4.5.2　mini-batch 的实现</a></p><p class="calibre1"><a href="part0000_split_051.html#nav_point_111" class="calibre5">4.5.3　基于测试数据的评价</a></p><p class="calibre1"><a href="part0000_split_052.html#nav_point_112" class="calibre5">4.6　小结</a></p><p class="calibre1"><a href="part0000_split_053.html#nav_point_113" class="calibre5">第 5 章　误差反向传播法</a></p><p class="calibre1"><a href="part0000_split_054.html#nav_point_114" class="calibre5">5.1　计算图</a></p><p class="calibre1"><a href="part0000_split_054.html#nav_point_115" class="calibre5">5.1.1　用计算图求解</a></p><p class="calibre1"><a href="part0000_split_054.html#nav_point_116" class="calibre5">5.1.2　局部计算</a></p><p class="calibre1"><a href="part0000_split_054.html#nav_point_117" class="calibre5">5.1.3　为何用计算图解题</a></p><p class="calibre1"><a href="part0000_split_055.html#nav_point_118" class="calibre5">5.2　链式法则</a></p><p class="calibre1"><a href="part0000_split_055.html#nav_point_119" class="calibre5">5.2.1　计算图的反向传播</a></p><p class="calibre1"><a href="part0000_split_055.html#nav_point_120" class="calibre5">5.2.2　什么是链式法则</a></p><p class="calibre1"><a href="part0000_split_055.html#nav_point_121" class="calibre5">5.2.3　链式法则和计算图</a></p><p class="calibre1"><a href="part0000_split_056.html#nav_point_122" class="calibre5">5.3　反向传播</a></p><p class="calibre1"><a href="part0000_split_056.html#nav_point_123" class="calibre5">5.3.1　加法节点的反向传播</a></p><p class="calibre1"><a href="part0000_split_056.html#nav_point_124" class="calibre5">5.3.2　乘法节点的反向传播</a></p><p class="calibre1"><a href="part0000_split_056.html#nav_point_125" class="calibre5">5.3.3　苹果的例子</a></p><p class="calibre1"><a href="part0000_split_057.html#nav_point_126" class="calibre5">5.4　简单层的实现</a></p><p class="calibre1"><a href="part0000_split_057.html#nav_point_127" class="calibre5">5.4.1　乘法层的实现</a></p><p class="calibre1"><a href="part0000_split_057.html#nav_point_128" class="calibre5">5.4.2　加法层的实现</a></p><p class="calibre1"><a href="part0000_split_058.html#nav_point_129" class="calibre5">5.5　激活函数层的实现</a></p><p class="calibre1"><a href="part0000_split_058.html#nav_point_130" class="calibre5">5.5.1　ReLU层</a></p><p class="calibre1"><a href="part0000_split_058.html#nav_point_131" class="calibre5">5.5.2　Sigmoid 层</a></p><p class="calibre1"><a href="part0000_split_059.html#nav_point_132" class="calibre5">5.6　Affine/Softmax 层的实现</a></p><p class="calibre1"><a href="part0000_split_059.html#nav_point_133" class="calibre5">5.6.1　Affine 层</a></p><p class="calibre1"><a href="part0000_split_059.html#nav_point_134" class="calibre5">5.6.2　批版本的 Affine 层</a></p><p class="calibre1"><a href="part0000_split_059.html#nav_point_135" class="calibre5">5.6.3　Softmax-with-Loss 层</a></p><p class="calibre1"><a href="part0000_split_060.html#nav_point_136" class="calibre5">5.7　误差反向传播法的实现</a></p><p class="calibre1"><a href="part0000_split_060.html#nav_point_137" class="calibre5">5.7.1　神经网络学习的全貌图</a></p><p class="calibre1"><a href="part0000_split_060.html#nav_point_138" class="calibre5">5.7.2　对应误差反向传播法的神经网络的实现</a></p><p class="calibre1"><a href="part0000_split_066.html#nav_point_139" class="calibre5">5.7.3　误差反向传播法的梯度确认</a></p><p class="calibre1"><a href="part0000_split_066.html#nav_point_140" class="calibre5">5.7.4　使用误差反向传播法的学习</a></p><p class="calibre1"><a href="part0000_split_067.html#nav_point_141" class="calibre5">5.8　小结</a></p><p class="calibre1"><a href="part0000_split_068.html#nav_point_142" class="calibre5">第 6 章　与学习相关的技巧</a></p><p class="calibre1"><a href="part0000_split_069.html#nav_point_143" class="calibre5">6.1　参数的更新</a></p><p class="calibre1"><a href="part0000_split_069.html#nav_point_144" class="calibre5">6.1.1　探险家的故事</a></p><p class="calibre1"><a href="part0000_split_069.html#nav_point_145" class="calibre5">6.1.2　SGD</a></p><p class="calibre1"><a href="part0000_split_069.html#nav_point_146" class="calibre5">6.1.3　SGD 的缺点</a></p><p class="calibre1"><a href="part0000_split_069.html#nav_point_147" class="calibre5">6.1.4　Momentum</a></p><p class="calibre1"><a href="part0000_split_069.html#nav_point_148" class="calibre5">6.1.5　AdaGrad</a></p><p class="calibre1"><a href="part0000_split_069.html#nav_point_149" class="calibre5">6.1.6　Adam</a></p><p class="calibre1"><a href="part0000_split_069.html#nav_point_150" class="calibre5">6.1.7　使用哪种更新方法呢</a></p><p class="calibre1"><a href="part0000_split_069.html#nav_point_151" class="calibre5">6.1.8　基于 MNIST 数据集的更新方法的比较</a></p><p class="calibre1"><a href="part0000_split_070.html#nav_point_152" class="calibre5">6.2　权重的初始值</a></p><p class="calibre1"><a href="part0000_split_070.html#nav_point_153" class="calibre5">6.2.1　可以将权重初始值设为 0 吗</a></p><p class="calibre1"><a href="part0000_split_070.html#nav_point_154" class="calibre5">6.2.2　隐藏层的激活值的分布</a></p><p class="calibre1"><a href="part0000_split_070.html#nav_point_155" class="calibre5">6.2.3　ReLU的权重初始值</a></p><p class="calibre1"><a href="part0000_split_070.html#nav_point_156" class="calibre5">6.2.4　基于 MNIST 数据集的权重初始值的比较</a></p><p class="calibre1"><a href="part0000_split_071.html#nav_point_157" class="calibre5">6.3　Batch Normalization</a></p><p class="calibre1"><a href="part0000_split_071.html#nav_point_158" class="calibre5">6.3.1　Batch Normalization 的算法</a></p><p class="calibre1"><a href="part0000_split_071.html#nav_point_159" class="calibre5">6.3.2　Batch Normalization的评估</a></p><p class="calibre1"><a href="part0000_split_072.html#nav_point_160" class="calibre5">6.4　正则化</a></p><p class="calibre1"><a href="part0000_split_072.html#nav_point_161" class="calibre5">6.4.1　过拟合</a></p><p class="calibre1"><a href="part0000_split_072.html#nav_point_162" class="calibre5">6.4.2　权值衰减</a></p><p class="calibre1"><a href="part0000_split_072.html#nav_point_163" class="calibre5">6.4.3　Dropout</a></p><p class="calibre1"><a href="part0000_split_073.html#nav_point_164" class="calibre5">6.5　超参数的验证</a></p><p class="calibre1"><a href="part0000_split_073.html#nav_point_165" class="calibre5">6.5.1　验证数据</a></p><p class="calibre1"><a href="part0000_split_073.html#nav_point_166" class="calibre5">6.5.2　超参数的最优化</a></p><p class="calibre1"><a href="part0000_split_073.html#nav_point_167" class="calibre5">6.5.3　超参数最优化的实现</a></p><p class="calibre1"><a href="part0000_split_074.html#nav_point_168" class="calibre5">6.6　小结</a></p><p class="calibre1"><a href="part0000_split_075.html#nav_point_169" class="calibre5">第 7 章　卷积神经网络</a></p><p class="calibre1"><a href="part0000_split_076.html#nav_point_170" class="calibre5">7.1　整体结构</a></p><p class="calibre1"><a href="part0000_split_077.html#nav_point_171" class="calibre5">7.2　卷积层</a></p><p class="calibre1"><a href="part0000_split_077.html#nav_point_172" class="calibre5">7.2.1　全连接层存在的问题</a></p><p class="calibre1"><a href="part0000_split_077.html#nav_point_173" class="calibre5">7.2.2　卷积运算</a></p><p class="calibre1"><a href="part0000_split_077.html#nav_point_174" class="calibre5">7.2.3　填充</a></p><p class="calibre1"><a href="part0000_split_077.html#nav_point_175" class="calibre5">7.2.4　步幅</a></p><p class="calibre1"><a href="part0000_split_077.html#nav_point_176" class="calibre5">7.2.5　3 维数据的卷积运算</a></p><p class="calibre1"><a href="part0000_split_077.html#nav_point_177" class="calibre5">7.2.6　结合方块思考</a></p><p class="calibre1"><a href="part0000_split_077.html#nav_point_178" class="calibre5">7.2.7　批处理</a></p><p class="calibre1"><a href="part0000_split_078.html#nav_point_179" class="calibre5">7.3　池化层</a></p><p class="calibre1"><a href="part0000_split_079.html#nav_point_180" class="calibre5">7.4　卷积层和池化层的实现</a></p><p class="calibre1"><a href="part0000_split_079.html#nav_point_181" class="calibre5">7.4.1　4 维数组</a></p><p class="calibre1"><a href="part0000_split_079.html#nav_point_182" class="calibre5">7.4.2　基于 im2col 的展开</a></p><p class="calibre1"><a href="part0000_split_079.html#nav_point_183" class="calibre5">7.4.3　卷积层的实现</a></p><p class="calibre1"><a href="part0000_split_079.html#nav_point_184" class="calibre5">7.4.4　池化层的实现</a></p><p class="calibre1"><a href="part0000_split_080.html#nav_point_185" class="calibre5">7.5　CNN的实现</a></p><p class="calibre1"><a href="part0000_split_081.html#nav_point_186" class="calibre5">7.6　CNN的可视化</a></p><p class="calibre1"><a href="part0000_split_081.html#nav_point_187" class="calibre5">7.6.1　第 1 层权重的可视化</a></p><p class="calibre1"><a href="part0000_split_081.html#nav_point_188" class="calibre5">7.6.2　基于分层结构的信息提取</a></p><p class="calibre1"><a href="part0000_split_082.html#nav_point_189" class="calibre5">7.7　具有代表性的 CNN</a></p><p class="calibre1"><a href="part0000_split_082.html#nav_point_190" class="calibre5">7.7.1　LeNet</a></p><p class="calibre1"><a href="part0000_split_082.html#nav_point_191" class="calibre5">7.7.2　AlexNet</a></p><p class="calibre1"><a href="part0000_split_083.html#nav_point_192" class="calibre5">7.8　小结</a></p><p class="calibre1"><a href="part0000_split_084.html#nav_point_193" class="calibre5">第 8 章　深度学习</a></p><p class="calibre1"><a href="part0000_split_085.html#nav_point_194" class="calibre5">8.1　加深网络</a></p><p class="calibre1"><a href="part0000_split_085.html#nav_point_195" class="calibre5">8.1.1　向更深的网络出发</a></p><p class="calibre1"><a href="part0000_split_085.html#nav_point_196" class="calibre5">8.1.2　进一步提高识别精度</a></p><p class="calibre1"><a href="part0000_split_085.html#nav_point_197" class="calibre5">8.1.3　加深层的动机</a></p><p class="calibre1"><a href="part0000_split_086.html#nav_point_198" class="calibre5">8.2　深度学习的小历史</a></p><p class="calibre1"><a href="part0000_split_086.html#nav_point_199" class="calibre5">8.2.1　ImageNet</a></p><p class="calibre1"><a href="part0000_split_086.html#nav_point_200" class="calibre5">8.2.2　VGG</a></p><p class="calibre1"><a href="part0000_split_086.html#nav_point_201" class="calibre5">8.2.3　GoogLeNet</a></p><p class="calibre1"><a href="part0000_split_086.html#nav_point_202" class="calibre5">8.2.4　ResNet</a></p><p class="calibre1"><a href="part0000_split_087.html#nav_point_203" class="calibre5">8.3　深度学习的高速化</a></p><p class="calibre1"><a href="part0000_split_087.html#nav_point_204" class="calibre5">8.3.1　需要努力解决的问题</a></p><p class="calibre1"><a href="part0000_split_087.html#nav_point_205" class="calibre5">8.3.2　基于 GPU 的高速化</a></p><p class="calibre1"><a href="part0000_split_087.html#nav_point_206" class="calibre5">8.3.3　分布式学习</a></p><p class="calibre1"><a href="part0000_split_087.html#nav_point_207" class="calibre5">8.3.4　运算精度的位数缩减</a></p><p class="calibre1"><a href="part0000_split_088.html#nav_point_208" class="calibre5">8.4　深度学习的应用案例</a></p><p class="calibre1"><a href="part0000_split_088.html#nav_point_209" class="calibre5">8.4.1　物体检测</a></p><p class="calibre1"><a href="part0000_split_088.html#nav_point_210" class="calibre5">8.4.2　图像分割</a></p><p class="calibre1"><a href="part0000_split_088.html#nav_point_211" class="calibre5">8.4.3　图像标题的生成</a></p><p class="calibre1"><a href="part0000_split_089.html#nav_point_212" class="calibre5">8.5　深度学习的未来</a></p><p class="calibre1"><a href="part0000_split_089.html#nav_point_213" class="calibre5">8.5.1　图像风格变换</a></p><p class="calibre1"><a href="part0000_split_089.html#nav_point_214" class="calibre5">8.5.2　图像的生成</a></p><p class="calibre1"><a href="part0000_split_089.html#nav_point_215" class="calibre5">8.5.3　自动驾驶</a></p><p class="calibre1"><a href="part0000_split_089.html#nav_point_216" class="calibre5">8.5.4　Deep Q-Network（强化学习）</a></p><p class="calibre1"><a href="part0000_split_090.html#nav_point_217" class="calibre5">8.6　小结</a></p><p class="calibre1"><a href="part0000_split_091.html#nav_point_218" class="calibre5">附录 A　Softmax-with-Loss 层的计算图</a></p><p class="calibre1"><a href="part0000_split_092.html#nav_point_219" class="calibre5">A.1　正向传播</a></p><p class="calibre1"><a href="part0000_split_093.html#nav_point_220" class="calibre5">A.2　反向传播</a></p><p class="calibre1"><a href="part0000_split_094.html#nav_point_221" class="calibre5">A.3　小结</a></p><p class="calibre1"><a href="part0000_split_095.html#nav_point_222" class="calibre5">参考文献</a></p><p class="calibre1"><a href="part0000_split_096.html#nav_point_223" class="calibre5">版权信息</a></p><p class="calibre4" id="calibre_pb_3"> </p>
<p class="calibre1">本书由「<a href="https://epubw.com" class="calibre6">ePUBw.COM</a>」整理，<a href="https://epubw.com" class="calibre6">ePUBw.COM</a> 提供最新最全的优质电子书下载！！！</p></body></html>
